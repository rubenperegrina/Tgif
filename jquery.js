/ *! v3.1.1 jQuery | (C) Fundación jQuery | jquery.org/license * /
! Función (a, b) { "use strict"; "objeto" == módulo typeof && "objeto" == typeof = module.exports module.exports a.document b (a, 0):?? Función (a) {if (a.document!) throw new Error ( "jQuery requiere una ventana con un documento"); return (a) b}:!? b (a)} ( "indefinido" = typeof ventana ventana: esto, la función ( a, b) { "use strict"; var c = [], d = a.document, e = Object.getPrototypeOf, f = c.slice, g = c.concat, h = c.push, i = c. indexOf, j = {}, k = j.toString, l = j.hasOwnProperty, m = l.toString, n = m.call (objeto), o = {}; función p (a, b) {b = b || d; var c = b.createElement ( "script"); c.text = a, b.head.appendChild (c) .parentNode.removeChild (c)} var q = "3.1.1", r = function (a, b) {return new r.fn.init (a, b)}, s = / ^ [\ s \ uFEFF \ xA0] + | [\ s \ uFEFF \ xA0] + $ / g, t = / ^ -ms - /, u = / - ([az]) / g, v = function (a, b) {return b.toUpperCase ()}; r.fn = r.prototype = {jQuery: q, constructor: r, longitud: 0, toArray: function () {return f.call (este)}, obtener: la función (a) {return nula == un f.call (este):?? a <0 este [a + esta .length]: esta [a]}, pushStack: function (a) {var b = r.merge (this.constructor (), a); return = b.prevObject esto, b}, cada uno: la función (a) { volver r.each (esto, a)}, mapa: function (a) {return this.pushStack (r.map (esto, la función (b, c) {return a.call (b, c, b)})) }, rebanada: function () {return this.pushStack (f.apply (este, argumentos))}, en primer lugar: function () {return this.eq (0)}, última: function () {return this.eq ( -1)}, eq: function (a) {var b = this.length, c = + a + (a? <b 0: 0); return this.pushStack (c> = 0 && c <b [esta [c] ]: [])}, final: function () {return this.prevObject || this.constructor ()}, empuje: h, para ordenar: c.sort, empalme: c.splice}, r.extend = r.fn .extend = function () {var a, b, c, d, e, f, g = argumentos [0] || {}, h = 1, i = arguments.length, j = 1;! a ( "booleano "== typeof g && (j = g, g = argumentos [h] || {}, h ++)," objeto "== typeof g || r.isFunction (g) || (g = {}), h = == i && (g = esto, h -); h <i; h ++) Si (null = (a = argumentos [h]!)) de (b en a) c = g [b], d = a [ b], g! == d && (j && && d (r.isPlainObject (d) || (e = r.isArray (d)))? (e? (e =! 1, F = c && r.isArray (c)? c : []): f = c && r.isPlainObject (c) c: {}, g [b] = r.extend (j, f, d)): void 0 == d && (g [b] = d) ); retorno g}, r.extend ({expando: "jQuery" + (q + Math.random ()).! sustituir (/ \ D / g, ""), isReady: 0, error: function (a) {throw new Error (a)}, NOOP: function () {}, isFunction: function (a) {return "función" === r.type (a)}, isArray: Array.isArray, IsWindow: function (una ) {return null = a && un a.window ===!}, isNumeric: function (a) {var b = r.type (a); return ( "número" === b || "cadena" === b !) && isNaN (a-parseFloat (a))}, isPlainObject: (!!! a) {var b, c; return (a || "[object Object]" == k.call (a) función) && (! (b = e (a)) || (c = l.call (b, "constructor") && b.constructor, "función" == typeof c && m.call (c) === n))}, isEmptyObject : function (a) {var b; para (b en a) return 1; 0 volver!}, tipo: function (a) {return nula == a a + "": "objeto" == typeof a ||? ? "función" == typeof un j [k.call (a)] || "objeto": typeof a}, globalEval: function (a) {p (a)}, camelCase: function (a) {return a. . sustituir (t, "ms") - reemplazar (u, v)}, nombreNodo: function (a, b) {return a.nodeName && a.nodeName.toLowerCase () === b.toLowerCase ()}, cada uno: la función (a, b) {var c, d = 0; si (w (a)) {for (c = a.length; d <c, d ++) si (b.call (un [d], D, a [ !! d]) === 1) salto} else para (d en a) si (b.call (un [d], D, a [d]) === 1) romper; volver a}, recorte: la función (a) {return null == un "" :( a + "") reemplazará (s, "")?.}, MakeArray: function (a, b) {var c = b || []; return null! = a && (w (Object (a)) r.merge (c, "cadena" == typeof un [a]:?? a): h.call (c, a)), c}, InArray: function (una , b, c) {return nula == b -1:? i.call (b, a, c)}, se funden: la función (a, b) {for (var c = + b.length, d = 0, e = a.length; d <c, d ++) un [e] ++ = b [d]; a.length retorno = e, a}, grep: function (a, b, c) {for (var d, e = [], f = 0, g = a.length, h = c;! f <g;! f ++) d = b (a [f], f), h && d == e.push (a [f]) ; e} regresar, el mapa: la función (a, b, c) {var d, e, f = 0, h = []; si (w (a)) por (d = a.length; f <d, f ++ ) e = b (a [f], f, c), null = e && h.push (e);! otra cosa para (f en a) e = b (a [f], f, c), null = e && h! .push (e); return g.apply ([], h)}, GUID: 1, Proxy: function (a, b) {var c, d, e, y si ( "cadena" == typeof b && (c = a [B], b = a, a = c), r.isFunction (a)) de retorno d = f.call (argumentos, 2), e = function () {return a.apply (b || esto, d .concat (f.call (argumentos)))}, e.guid = = a.guid a.guid || r.guid ++, e}, ahora: Date.now, soporte: o}), "función" == typeof símbolo && (r.fn [Symbol.iterator] = c [Symbol.iterator]), r.each ( "Número de Boole cadena Símbolo función matriz Fecha RegExp error de objeto" .split ( ""), la función (a, b) { j [ "[objeto" + b + "]"] = b.toLowerCase ()}); la función w (a) {var b = a && !! "longitud" en un a.length &&, c = r.type (a); retorno "función"! == c &&! r.isWindow (a) && ( "array" === === 0 c || B || "número" == typeof b && b> 0 && b-1 en a)} var x = función (a) {var b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u = "chisporroteo" + 1 * nueva fecha, v = a.document, w = 0, x = 0, y = (ja), Z = (ja), a = ja (), B = function (a, b) {return a = == b && (l = 0), 0}, C = {}. hasOwnProperty, D = [], E = D.pop, F = D.push, G = D.push, H = D.slice, me = function (a, b) {for (var c = 0, d = a.length; c <d, c ++) si (a [c] === b) la devolución c;} return-1, J = "marcada | seleccionadas | asíncrono | autofoco | reproducción automática | controles | aplazar | discapacitados | oculto | ismap | bucle | múltiple | abierto | sólo lectura | obligatorio | con ámbito ", K =" [\\ x20 \\ t \\ r \\ n \\ f] ", L =" (?:. \\\\ | [\\ W] | [^ \ 0 - \\ xa0]) + ", M =" \\ [ "+ K +" * ( "+ L + ") (?:" + K + "* ([* ^ $ | ~!] =?)" + K + "* (?: '((:?. \\\\ | [^ \\\\'] ) *) '| \ "((:?. \\\\ | [^ \\\\\"]) *) \ "| (" + L + ")) |)" + K + "* \\]" , N = ":(" + L + ") (: \\ (((? '((:?. \\\\ | [^ \\\\']) *) '| \" ((?: \ . \\\ | [^ \\\\\ "]) *) \") | ((:?. \\\\ | [^ \\\\ () [\\]] | "+ H +") *) | *) \\) |) ", O = new RegExp (K +" + "," g "), P = new RegExp (" ^ "+ K +" + | ((:.? ^ | [^ \ \\\]) (?:. \\\\) *) "+ K +" + "," g "), Q = new RegExp (" * "+ K +" $ ^ "+ K +" * "), R = new RegExp ( "^" + K + "* ([> + ~] |" + K + ")" + K + "*"), S = new RegExp ( "=" + K + "* ([^ \\] "\"] *)? "+ K +" * \\] "," g "), T = new RegExp (N), T = new RegExp (" ^ "+ L +" $ "), V = {ID: nueva RegExp ( "^ # (" + L + ")"), CLASE: new RegExp ( "^ \\ (." + L + ")"), la etiqueta: new RegExp ( "^ (" + L + "| [*] ) "), ATTR: new RegExp (" ^ "H +), PSEUDO: new RegExp (" ^ "+ N), NIÑO: new RegExp (" ^ :( única | primera | última | enésima | enésima última) - (niños | de tipo a) (?: \\ ( "+ K +" * (incluso | extraño | (([+ -] |) (\\ d *) n |) "+ K +" * (: ([? + -] |) "+ K +" * (\\ d +) |)) "+ K +" * \\) |) "," i "), bool: new RegExp (" ^ (?: "+ J +") $ "," i "), needsContext: new RegExp (" ^ "+ K +" * [> + ~] |: (incluso | extraño | eq | GT | lt | enésima | primera | última) (?: \\ ( "+ K +" *? (?? (: - \\ d) \\ * d) "+ K +" * \\) |) (= [^ -] | $) "," i ")}, W = / ^ (entrada ?: | selecto | área de texto botón |) $ / I, X = / ^ h \ d $ / i, Y = / ^ [^ {] + \ {\ s * \ [nativa \ w /, Z = / ^ (?: # ([\ w -] +) | (\ w +) | \ ([\ w -] +).) $ /, $ = / [+ ~] /, _ = new RegExp ( " \\\\ ([\\ da-f] {1,6} "+ K +" |? ( "+ K +") |.) "," IG "), aa = function (a, b, c) { ?!? var d = "0 x" + b-65536; retorno d == || d c b: d <0 String.fromCharCode (d + 65536): String.fromCharCode (d >> 10 | 55296,1023 + D | 56320 )}, BA = / ([\ 0- \ x1f \ x7F] | ^ - \ d) |? ^ - $ | [^ \ 0- \ x1f \ x7f- \ uFFFF \ w -] / g, ca = function (a, b) {return b "\ 0" === un "\ uFFFD":?? a.slice (0, -1) + "\\" + a.charCodeAt (a.length-1) .toString (16) + "": "\\"! + a}, da = function () {m ()}, ea = ta (function (a) {return a.disabled === 0 && ( "forma" en una || "etiqueta" en a)}, {dir: "parentNode", al lado: "leyenda"}); try {G.apply (D = H.call (v.childNodes), v.childNodes), D v [ .childNodes.length] .nodeType} catch (FA) {G = {aplicar:? D.Longitud función (a, b) {F.apply (a, H.call (b))}: function (a, b) {var c = a.length, d = 0, mientras que (a [C ++] = b [d ++]); a.length = C-1}}} function ga (a, b, d, e) {var f, h, j, k, l, o, r, s = b && b.ownerDocument, w = b b.nodeType:?! 9; si (d = d || [], "cadena" = typeof a || a | !!!!?! | 1 == w && 9 == == 11 && w w) de retorno d; si (e && ((b b.ownerDocument || b: v) == n && m (b), b = b || n, p)) {if (11! == w && (l = Z.exec (a))) si (f = l [1]) {if (9 === w) {if (! (j = b.getElementById (f))) de retorno d; si (j.id === f) de retorno d.push (j), d} else if (s && (j = s.getElementById (f)) && T (B, j) && j. Identificación del === f) de retorno d.push (j), d} else {if (l [2]) volver G.apply (d, b.getElementsByTagName (a)), d; if ((f = l [3 ]) && && c.getElementsByClassName b.getElementsByClassName) volver G.apply (d, b.getElementsByClassName (f)), d} if (c.qsa &&! a [a + ""] && (! q ||! q.test (a) )) {if (1 == w) s = b, r = a;! else if ( "objeto" == b.nodeName.toLowerCase ()) {(k = b.getAttribute ( "id"))!? k = k.replace (BA, CA): b.setAttribute ( "id", k = u), o = g (a), h = o.length, mientras que (h -) o [h] = "# "+ k +" "+ sa (o [h]);. r = o.join (", "), s = $ ensayo (a) && qa (b.parentNode) || b} si (r) {return tratar G.apply (d, s.querySelectorAll (r)), d} catch (x) {} finally {k === u && b.removeAttribute ( "id")}}} return i (a.replace (P, "$ 1 "), b, d, e)} function ha () {var a = []; la función b (c, e) {a.push retorno (c +" ")> d.cacheLength && eliminar b [a.shift ()] , b [c + ""] = e} return b} función de AI (a) {return una [u] = 0, una función} ja (a) {var b = n.createElement! ( "fieldset"); try { volver !! una (b)} catch (c) {return! 1} finally {b.parentNode && b.parentNode.removeChild (b), b = null}} function ka (a, b) {var c = a.split ( "|"), e = c.length, mientras que (e -) d.attrHandle [c [e]] = b} la función de (a, b) {var c = b && a, d = c && 1 === a. nodeType && && 1 === b.nodeType a.sourceIndex-b.sourceIndex; si (d) de retorno d; si (c), mientras que (c = c.nextSibling) si (c === b) volver-1; devolver un 1?: -1} function ma (a) {función de retorno (b) {var c = b.nodeName.toLowerCase (); return "entrada" === === c && b.type a}} function na (a) {función de retorno (b) {var c = b.nodeName.toLowerCase (); return (c || === "botón" "entrada" === c) && b.type === a}} oa la función (a) {return función (b) {return "forma" en b.parentNode b && b.disabled === 1 "etiqueta" en b "etiqueta" en b.parentNode b.parentNode.disabled === a:?!??? b.disabled === a: === b.isDisabled a || == b.isDisabled un ea && (b) === a:!! b.disabled === un: "etiqueta" en b && b.disabled === a} } function pa (a) {return i bis (función (b) {return = b + b, IA (function (c, d) {var e, f = a ([], c.length, b), g = f .length, mientras que (g -) c [e = f [g]] && (! c [e] = (d [e] = c [e]))})})} la función de control de calidad (a) {return ! a && "indefinido" = typeof a.getElementsByTagName && a} c = ga.support = {}, f = ga.isXML = function (a) {var b = a && (a.ownerDocument || a) .documentElement; b && volver !! "HTML" == b.nodeName}, m = ga.setDocument = function (a) {var b, e, g = a a.ownerDocument || a:? v; g retorno == === n && 9 g! .nodeType && g.documentElement? (n = g, o = n.documentElement, p =! f (n), v! == n && (e = n.defaultView) && e.top! == e && (e.addEventListener? e. addEventListener ( "descarga", da, 1!): e.attachEvent && e.attachEvent ( "onunload", da)), c.attributes = ja (function (a) {return a.className = "i", a.getAttribute! ( "className")}), c.getElementsByTagName = ja (función (a) {return a.appendChild (n.createComment ( "")) ,! a.getElementsByTagName ( "*"). longitud}), c.getElementsByClassName = Y.test (n.getElementsByClassName), c.getById = ja (function (a) {return o.appendChild (a) .id = u,! n.getElementsByName ||! n.getElementsByName (u) .length}) ?, c.getById (d.filter.ID = function (a) {var b = a.replace (_, aa); función de retorno (a) {return a.getAttribute ( "id") === b}} , d.find.ID = function (a, b) {if ( "indefinido" = typeof b.getElementById && p!) {var c = b.getElementById (a); devuelva c [c]: []}}): (d.filter.ID = function (a) {var b = a.replace (_, aa); función de retorno (a) {var c = "indefinido" = typeof a.getAttributeNode && a.getAttributeNode ( "id"); c && volver c.value === b}}, d.find.ID = function (a, b) {if ( "indefinido"! = typeof b.getElementById && p) {var c, d, e f = b.getElementById ( a), si (f) {if (c = f.getAttributeNode ( "id"), c && c.value === a) la devolución [f]; e = b.getElementsByName (a), d = 0; while (f = e [d ++]) si (c = f.getAttributeNode ( "id"), c && c.value === a) la devolución [f]} return []}}),? = función d.find.TAG c.getElementsByTagName (a, b) {return "indefinido" = typeof b.getElementsByTagName b.getElementsByTagName (a):? c.qsa b.querySelectorAll (a):? nula 0}: la función (a, b) {var c, d = [], e = 0, f = b.getElementsByTagName (a), si ( "*" === a) {while (c = f [e ++]) 1 === c.nodeType && d.push (c); retorno d} return f}, d.find.CLASS = función c.getElementsByClassName && (a, b) {if ( "indefinido"! = typeof b.getElementsByClassName && p) volver b.getElementsByClassName (a)}, r = [], q = [], (c.qsa = Y.test (n.querySelectorAll)) && (ja (function (a) {o.appendChild (a) .innerHTML = "<a id='"+u+"'> </ a > <select id = ' "+ u +" - \ r \\' msallowcapture = ''> <option selected = ''> </ option> </ select> ", a.querySelectorAll (" [msallowcapture ^ = ''] ") && .length q.push (" [* ^ $] = "+ K +" * (?: '' | \ "\"). "), a.querySelectorAll (" [seleccionado] ") de longitud || q.push . ( "\\ [" + K + "* (?: valor |" + J + ")"), a.querySelectorAll ( "[id ~ =" + u + "-]") de longitud || q.push ( "~ = "), a.querySelectorAll (": comprueba ") de longitud || q.push (.": comprueba "), a.querySelectorAll (" un # "+ u +" + * ".) longitud || q.push (" . #. + [+ ~] ")}), ja (function (a) {a.innerHTML =" <a href='' disabled='disabled'> </a> <select = discapacidad discapacitado "> < opción /> </ select> "; var b = n.createElement"; b.setAttribute ( "entrada) (" tipo "," oculto "), a.appendChild (b) .setAttribute (" nombre "," D " .), a.querySelectorAll ( "[name = d]") && longitud q.push ( "nombre" + K + "* [* ^ $ | ~!] =?"), 2 == a.querySelectorAll ( ": habilitado ") && .length q.push (": activar ",": desactivado "!), o.appendChild (a) .disabled = 0,2 == a.querySelectorAll (": desactivado ") && longitud q.push (.": permitido ",": desactivado "), a.querySelectorAll (" * ,: x "), q.push (" *:. ")})), (c.matchesSelector = Y.test (s = o.matches || o.webkitMatchesSelector || o.mozMatchesSelector || o.oMatchesSelector || o.msMatchesSelector)) && ja (función (a) {c.disconnectedMatch = s.call (a, "*"), s.call (a, "[s = ''!]: x" r.push), ( "! =", N)}), q = q.length && nueva RegExp (q.join ( "|")), r = r.length && nueva RegExp (r.join ( "|"))?, b = Y.test (o.compareDocumentPosition), t = B || Y.test (o.contains) función (a, b) {var c = 9 === ? a.nodeType a.documentElement: a, d = b && b.parentNode; devolver una === d || (d || 1 || == d.nodeType (c.contains c.contains (d!!!!? ): a.compareDocumentPosition && 16 y a.compareDocumentPosition (d)))}: la función (a, b) {if (b), mientras que (b = b.parentNode) si (b === a) return 0;} return 1,! ? B = b función (a, b) {if (una === b) la devolución l = 0,0; var d = a.compareDocumentPosition- b.compareDocumentPosition; retorno d d:!!!? (d = (a ?!? .ownerDocument || a) === (b.ownerDocument || b) a.compareDocumentPosition (b): 1,1 + D || c.sortDetached && b.compareDocumentPosition (a) === === d a n | ?? | a.ownerDocument === v && t (V, a) - 1: b === === n || b.ownerDocument v && t (v, b) 1: Ki (k, a) -I (? ? k, b): 0: 4 + D -1: 1)}: la función (a, b) {if (una === b) la devolución l = 0,0; var c, d = 0, e = a. parentNode, f = b.parentNode, g = [a], h = [b]; si devolver una === n -1 (e || f!):??? === b n 1: e - ? 1: f 1: k I (k, a) -I (k, b):? 0, si (e === f) volver la (a, b), c = a, mientras que (c = c. parentNode) g.unshift (c); c = b, mientras que (c = c.parentNode) h.unshift (c), mientras que (g [d] === h [d]) d ++;? d la vuelta (g [d], h [d]): g [d] === v -1:?? h [d] === v 1: 0}, n): n}, ga.matches = function (a, b) {ga retorno (a, null, null, b)}, ga.matchesSelector = function (a, b) {if ((a.ownerDocument || a)! == n && m (a), b = b.replace (S "= '$ 1']"), p c.matchesSelector && &&! A [b + ""] && (! r ||! r.test (b)) && (! q ||! q.test (b)) ) try {var d = s.call (a, b); if (! d || || c.disconnectedMatch a.document && 11 == a.document.nodeType) de retorno d} catch (e) {} ga retorno (b , n, nula, [a]). longitud> 0}, ga.contains = function (a, b) {return (a.ownerDocument || a)! == n && m (a), t (a, b)} , ga.attr = function (a, b) {(a.ownerDocument || a) == n && m (a);! var e = d.attrHandle [b.toLowerCase ()], f = e && C.call (d. attrHandle, b.toLowerCase ()) e (a, B, P):?!?!? nula 0; vuelve vacía 0 == f f: c.attributes || p a.getAttribute (b) :( f = a.getAttributeNode (b)) && f.specified f.value: null}, ga.escape = function (a) {return (a + "") reemplazará (BA, CA)}, ga.error = function (a). {throw new error ( "error de sintaxis, la expresión no reconocida:" + a)}, ga.uniqueSort = function (a) {var b, d = [], e = 0, f = 0; si (l = c!. detectDuplicates, k =! c.sortStable && a.slice (0), a.sort (B), l) {while (b = a [f ++]) b === una [f] && (e = d.push (f )), mientras que (e -) a.splice (d [e], 1)} return k = null, a}, e = ga.getText = function (a) {var b, c = "", d = 0, f = a.nodeType; si (f) {if (1 === === f || 9 || f 11 === f) {if ( "cadena" == typeof a.textContent) devolver una .textContent; para (a = a.firstChild; a; a = a.nextSibling) + c = e (a)} else if (3 === === f || 4 f) volver a.nodeValue} else while ( b = a [d ++]) c + = e (b); devuelva c}, d = ga.selectors = {cacheLength: 50, createPseudo: IA, partido: V, attrHandle: {}, encontrará: {}, relativa: { ">": {dir: "parentNode", en primer lugar: 0} ",": {dir: "parentNode"} "+": {dir: "previousSibling", en primer lugar: 0}, "~": { dir: "previousSibling"}}, prefiltro: {ATTR: function (a) {return a [1] = a [1] .Colocar (_, aa), un [3] = (a [3] || un [ 4] || a [5] || ""). sustituir (_, aa), "~ =" === a [2] && (a [3] = "" + a [3] + "") , a.slice (0,4)}, NIÑO: function (a) {return a [1] = a [1] .tolowercase () ", n-ésima" === a [1] .slice (0,3) ? (a [3] || ga.error (a [0]), una [4] = + (a [4] a [5] + (a [6] || 1):? 2 * ( "incluso "=== a [3] ||" extraño "=== a [3])), un [5] = + (a [7] + a [8] ||" extraño "=== a [3 ])): a [3] && ga.error (a [0]), a}, PSEUDO: la función (a) {var b, c = a [6] && a [2]; volver V.CHILD.test ( ? a [0]) null: (a [3] a [2] = a [4] || un [5] || "":? c && t.test (c)! && (b = g (c, 0 )) && (b = c.indexOf ( ")", c.length-b) -c.length) && (a [0] = a [0] .slice (0, b), a [2] = C .slice (0, b)), a.slice (0,3))}}, filtro: {TAG: function (a) {var b = a.replace (_, aa) .tolowercase (); return "* "=== una función () {return 0}: la función (a) {return a.nodeName && a.nodeName.toLowerCase () === b}}, CLASE: function (a) {var b = [a + ""]; retorno b || (b = new RegExp ( "(^ |" + K + ")" + a + "(" + K + "| $)")) && y (a, la función (a) {return b. de prueba ( "cadena" == typeof a.className && || a.className "indefinido" = typeof a.getAttribute && a.getAttribute ( "clase") || ""!)})}, ATTR: function (a, b, c) ? {función de retorno (d) {var e = ga.attr (d, a); devolver null == e "! =" === b: b || (e + = "", "=" === b e === C:? "=" === == d e c:?! "^ =" === b c && 0 === e.indexOf (c):? "* =" === ? b c && e.indexOf (c)> - 1: "$ =" === b c && e.slice (-c.length) === C: "~ =" === b ( "" + e?. sustituir (O, "") + "") .indexOf (c)> - 1: "| =" === b && (e === c || e.slice (0, c.length + 1) == = c + "-"))}}, NIÑO:!! función (a, b, c, d, e) {var f = "enésimo" == a.slice (0,3), g = "último" = ? = a.slice (-4), h = "del tipo" === b; devolver la función 1 === === 0 && d e (a) {return !! a.parentNode}: function (b, c , i) {var j, k, l, m, n, o, p = f == g "nextSibling":!? "previousSibling", q = b.parentNode, r = h && b.nodeName.toLowerCase (), s ! = i && h, t = 1; if (! q) {if (f) {while (p) {m = b;?, mientras que (m = m [p]) si (h m.nodeName.toLowerCase () === r: 1 === m.nodeType) devuelve 1; o = p = "sólo" === a && && o "nextSibling"} return 0} if (o = [g q.firstChild:!!! q? .lastChild], g && s) {m = q = l, m [u] || (m [u] = {}), k = l [m.uniqueID] || (l [m.uniqueID] = {}) , j = k [a] || [], n = j [0] === w && j [1], t = n && j [2], m = n && q.childNodes [n], mientras que (m = ++ n && m && m [ p] || (t = n = 0) || o.pop ()) si (1 === m.nodeType && ++ t && m === b) {k [a] = [w, n, t]; romper}} else if (s && (m = D, A = m [u] || (m [u] = {}), k = l [m.uniqueID] || (l [m.uniqueID] = {} ), j = k [a] || [], n = j [0] === w && j [1], t = n), t === 1), mientras que (m = ++ n && m && m [p]! | | (t = n = 0) || o.pop ()) si ((h m.nodeName.toLowerCase () === r: 1 === m.nodeType) && ++ t && (s && (l = m [u] || (m [u] = {}), k = l [m.uniqueID] || (l [m.uniqueID] = {}), k [a] = [w, t]), m === b)) romper; return t = e, t === d || t% d === 0 && t / d> = 0}}}, PSEUDO: function (a, b) {var c, e = d.pseudos [a] || [d.setFilters a.toLowerCase ()] || ga.error? ( "pseudo sin apoyo:" + a); return e [u] e (b): e.length> 1? (c = [a, a, "", b], d.setFilters.hasOwnProperty (a.toLowerCase ())? ia (función (a, c) {var d, f = e (a, b), g = f.length, mientras que (g -) d = I (a, f [g]), un [d] = (c [d] = f [g])}): la función (a) {return e (a, 0, c)}): e}}, pseudos: {no: IA (function (a) {var b = [], c = [], d = h (a.replace (P, "$ 1 ")); el retorno d [u] ia (function (a, b, c, e) {var f, g = d (a, nula, e, []), h = a.length;? while (h- -) (f = g [h]) && (una [h] = (b [h] = f!))}): function (a, e, f) {return b [0] = a, d (b , null, f, c), b [0] = null, c.pop ()}}), tiene: i bis (función (a) {función de retorno (b) {ga retorno (a, b) .length> 0}}), contiene: i bis (función (a) {return a = a.replace (_, aa), función (b) {return (b.textContent || || b.innerText e (b)) indexOf. (a)> - 1}}), lang: IA (función (a) {return U.test (a || "") || ga.error ( "no soportado lang:" + a), a = a.replace (_, aa) .tolowercase (), función (b) {var c; hacer si (? c = p b.lang: b.getAttribute ( "xml: lang") || b.getAttribute ( "lang")) volver c.toLowerCase c = (), c === === 0 a || c.indexOf (a + "-"), mientras que ((b = b.parentNode) && 1 === b.nodeType); volver! 1}}), objetivo: la función (b) {var c = a.location && a.location.hash; return c && c.slice (1) === b.id}, raíz: la función (a) {return una === o}, se centran: (! n.hasFocus || n.hasFocus ()) función (a) {return una === n.activeElement && && !! (a.type || || ~ a.href a.tabIndex) (! 1): (0):}, habilitado oa, oa personas con discapacidad, comprobado: la función (a) {var b = a.nodeName.toLowerCase (); return "entrada" === b && !! a.checked | ! | "opción" === b && !! a.selected}, seleccionado: función (a) {return a.parentNode && a.parentNode.selectedIndex, a.selected === 0}, vacío: la función (a) {for ( a = a.firstChild; a; a = a.nextSibling) si (a.nodeType <6) return 1;} return 0, padre:!!! función (a) {return d.pseudos.empty (a)}, cabecera: la función (a) {return X.test (a.nodeName)}, de entrada: function (a) {return W.test (a.nodeName)}, un botón: la función (a) {var b = a.nodeName. toLowerCase (); retorno "de entrada" === b && "botón" === a.type || "botón" === b}, texto: function (a) {var b; return "entrada" === una .nodeName.toLowerCase () && "texto" === a.type && (null == (b = a.getAttribute ( "tipo")) || "texto" === b.toLowerCase ())}, en primer lugar: pa (function () {return [0]}), última: pa (function (a, b) {return [B-1]}), eq: pa (function (a, b, c) {return [c < ? 0 c + b: c]}), incluso: pa (function (a, b) {for (var c = 0; c <b, c + = 2) a.push (c); volver a}), impar : pa (function (a, b) {for (var c = 1, c <b, c + = 2) a.push (c); volver a}), LT: pa (function (a, b, c) { for (var d = c <0 c + b: c; - d> = 0;) a.push (d); volver a}), GT: pa (function (a, b, c) {for ( ? var d = c <0 c + b: c, d ++ <b;) a.push (d); volver a})}}, d.pseudos.nth = d.pseudos.eq; para (b en {la radio: 0, casilla: 0, archivo: 0, contraseña: 0, imagen: 0!!!!!}) d.pseudos [b] = ma (b), para (b {en presentar: 0, reset !: 0}) d.pseudos [b] = na (b); ra la función () {} = ra.prototype d.filters = d.pseudos, d.setFilters = new ra, g = ga.tokenize = function ( a, b) {var c, e, f, g, h, i, j, k = z [a + ""]; si (k) de retorno b 0: k.slice (0); h = a, i? = [], j = d.preFilter;! mientras (h) {c && (e = Q.exec (h)) || (e && (h = h.slice (e [0] .length) || h), i.push (f = [])), c = 1, (e = R.exec (h)) && (c = e.shift (), f.push ({valor: C, tipo: e [0 ] .Colocar (P, "")}), h = h.slice (c.length)); for (g en d.filter) (e = V [g] .exec (h)) || j [! g] && (e = j [g] (e)) || (c = e.shift (), f.push ({valor: C, tipo: g, coincide: e}), h = h.slice (c.length)); si (c) ruptura} return b h.length: h ga.error (a):?!? z (a, i) .slice (0)}; la función sa (a) {for (var b = 0, c = a.length, d = ""; b <c, b ++) + d = a [b] .value; retorno d} la función TA (a, b, c) {var d = b. dir, e = b.next, f = e || d, g = c && "parentNode" === f, h = x ++;? volver b.first función (b, c, e) {while (b = b [ d]) si (1 === b.nodeType || g) volver a (b, c, e), y devuelve 1}: function (b, c, i) {var j, k, l, m = [! w, h]; si (i) {while (b = b [d]) si ((1 === b.nodeType || g) && a (b, c, i)) return 0} else mientras que (b b = [d]) si (1 === b.nodeType || g) si (L = b [u] || (b [u] = {}), k = l [b.uniqueID] || ( l [b.uniqueID] = {}), e && e === b.nodeName.toLowerCase ()) b = b [d] || b; else {if ((j = k [f]) ​​&& j [0] = == w && j [1] === h) de retorno m [2] = j [2]; if (! k [f] = m, m [2] = a (b, c, i)) return 0} return !? 1}} function ua (a) {return a.length> 1 función (b, c, d) {var e = a.length, mientras que (e -) si (a [e] (b, c! , d)) return 1; return 0}:! a [0]} v una función (a, b, c) {for (var d = 0, e = b.length; d <e, d ++) ga (una , b [d], c); devuelva c} wa función (a, b, c, d, e) {for (var f, g = [], h = 0, i = a.length, j = null! = b; h <i; h ++) (! f = a [h]) && (c && c (f, d, e) || (g.push (f), j && b.push (h))); return g } la función xa (a, b, c, d, e, f) {return d &&! d [u] && (d = xa (d)), e &&! e [u] && (e = xa (e, f) ), IA (función (f, g, h, i) {var j, k, l, m = [], n = [], o = g.length, p = f || VA (b || "* ", h.nodeType [h]:? h, []), q = f && a || b t:!?!? wa (p, m, a, h, i), r = c || e (f? R: O || d) []: g: q; si (c && c (q, r, h, i), d) {j = wa (r, n), d (j, [], h, i? ), k = j.length; while (! k -) (l = j [k]) && (r [n [k]] = (q [n [k]] = l))} if (f) {if (e || a) {if (e) {j = [], k = r.length, mientras que (k -) (l = r [k]) && j.push (q [k] = l) ; e (null, r = [], j, i)} k = r.length, mientras que (k -) (l = r [k]) && (j = e I (f, l): m [? k])> - 1 && (f [j] = (g [j] = l!))}} else r = wa: r), e (R === g r.splice (o, r.length?) ? e (nulo, g, r, i): (r g,)}) función G.apply} ya (a) {for (var b, c, e f = a.length, g = d.relative [ a [0] .type], h = g || d.relative [ ""], i = 1 g:? 0, k = ta (function (a) {return una === b}, h, 0! ), l = ta (function (a) {return I (b, a)> - 1}!, h, 0), m = [función (a, c, d) {var e = g && (d || ! c == j) || ((b = c) .nodeType k (a, c, d):? l (a, c, d)); b = null retorno, e]}; i <f; i ++ ) si (c = d.relative [a [i] .type]) m = [ta (UA (m), c)]; else {si (c = d.filter [a [i] .type] .apply (nulo, a [i] .matches), c [u]) {for (e = i ++; e <f; e ++) si (d.relative [a [e] .type]) romper; xa retorno ( i> 1 && ua (m), i> 1 && sa (a.slice (0, i-1) .concat ({valor: "" === a [i-2] .type? "*": ""})) .Colocar (P, "$ 1"), c, i <e && ya (a.slice (i, e)), e <f && ya (a = a.slice (e)), e <f && sa (a))} m. push (c)} return ua (m)} function za (a, b) {var c = b.length> 0, e = a.length> 0, f = function (f, g, h, i, k) {var l, o, q, r = 0, s = "0", t = f && [], u = [], v = j, x = f || e && d.find.TAG ( "*", k) , y = w + v = null == 1:?! Math.random () || 0,1, z = x.length; for (k && (j = g === n || g || k); s = ! = null = z && (L = x [s]); s ++) {if (e && l) {o = 0, g || || l.ownerDocument === n (m (l), h = p);!, mientras (q = a [o ++]) si (q (l, g || n, h)) {i.push (l); descanso}! k && (w = y)} c && ((l = q && l) && r-- , f && t.push (l))} if (r + = s, c && s == r) {o = 0;!, mientras que (Q = b q [o ++]) (t, u, g, h), si (f) {if (r> 0), mientras que (s -) t [s] || T [s] || (T [s] = E.call (i)); u = wa (u)} G.apply ( ! i, u), k && f && u.length> 0 && r + b.length> 1 && ga.uniqueSort (i)} return k && (w = y, j = v), t}; devuelva c ia (f): f} return h = ga.compile = función (a, b) {var c, d = [], e = [], f = a [a + ""]; (! f) si {b || (b = g (una )), c = b.length, mientras que (c -) f = ya (b [c]), f [u] d.push (f):? e.push (f); f = a (a, za (e, d)), f.selector = a} return f}, i = ga.select = function (a, b, c, e) {var f, i, j, k, l, m = "función "== typeof a && a, n = e && g (a = m.selector || a); if (! c = c || [], 1 === n.length) {if (i = n [0] = n [0] .slice (0), i.length> 2 && "ID" === (j = i [0]). escriba && 9 === b.nodeType && && p d.relative [i [1] .type]) {if ( b = (d.find.ID (j.matches [0] .Colocar (_, aa), b) || []) [0] ,! b) c retorno; m && (b = b.parentNode), una = a.slice (i.shift () value.length.) f} = V.needsContext.test (a) 0: i.length, mientras que (f -) {if (j = i [f], d? .relative [k = j.type]) romper;. if ((l = d.find [k]) && (e = l (j.matches [0] .Colocar (_, aa), $ ensayo (i [ 0] .type) && qa (b.parentNode) || b))) {if (i.splice (f, 1), a = e.length && sa (i) ,! a) G.apply volver (c, e) , c;}}} ruptura de retorno (m || h (a, n)) (! e, b, p, c, b (a) && qa .test || $ (b.parentNode) || b), c}, c.sortStable = u.split ( ""). sort (B) .join ( "") === u, = c.detectDuplicates !! l, m (), c.sortDetached = ja (function ( a) {return 1 y a.compareDocumentPosition (n.createElement ( "fieldset"))}), ja (function (a) {return a.innerHTML = "<a href='#'> </a>", "#" === a.firstChild.getAttribute ( "href")}) || ka ( "tipo | href | altura | anchura", la función (a, b, c) {if volver a.getAttribute (b, (c!) "tipo" === b.toLowerCase () 1: 2)}), c.attributes && ja (function (a) {return a.innerHTML = "<input />", a.firstChild.setAttribute ( "valor", ""), "" === a.firstChild.getAttribute ( "valor")}) || ka ( "valor", la función (a, b, c) {if (! c && "entrada" === a. nodeName.toLowerCase ()) de retorno a.defaultValue}), ja (function (a) {return nula == a.getAttribute ( "desactivado")}) || ka (J, la función (a, b, c) {var (! c), d si devolver un [b] === 0 b.toLowerCase () :( d = a.getAttributeNode (b)) && d.specified d.value: null}), ga} (un?!? ); r.find = x, r.expr = x.selectors, r.expr [ ":"] = r.expr.pseudos, r.uniqueSort = = r.unique x.uniqueSort, R.TEXT = x.getText , r.isXMLDoc = x.isXML, r.contains = x.contains, r.escapeSelector = x.escape; var y = función (a, b, c) {var d = [], e = 0 == vacío! c, mientras que ((a = a [b]) && 9 == a.nodeType!) si (1 === a.nodeType) {if (e && r (a) .is (c)) romper; d.push (una )} return d}, z = function (a, b) {for (var c = []; a; a = a.nextSibling) 1 === a.nodeType && a == b && c.push (a);! devuelva c }, A = r.expr.match.needsContext, B = / ^ <([az] [^ \ / \ 0>: \ x20 \ t \ r \ n \ f] *) [\ x20 \ t \ r \ ? n \ f] * \ /> (:? <\ / \ 1> |) $ / I, C = / ^ [^:. # \ [\,]. * $ /; función D (a, b, c) {return r.isFunction {return !! b.call (a, d, a) == c}) (b) r.grep (a, la función (a, d?):!? b.nodeType r. grep (a, la función (a) {return una === == b c!}):!? "cadena" = typeof b r.grep (a, la función (a) {return i.call (b, a) !> -1 == c}): C.test (? b) r.filter (b, a, c) :( b = r.filter (b, a), r.grep (a, la función (a) {i.call volver (b, a)> - 1 == c && 1 === a.nodeType!}))} r.filter = function (a, b, c) {var d = b [0]; devuelva c && (a = ": no (" + a + ")"), 1 === === b.length && 1 d.nodeType r.find.matchesSelector (d, a) [d]:?? []: r.find .matches (a, b, r.grep (función (a) {return 1 a.nodeType ===}))}, r.fn.extend ({encontrar: la función (a) {var b, c, d = this.length, e = presente; if (! "cadena" = typeof a) this.pushStack retorno (r (a) .Filter (function () {for (b = 0, b <d, b ++) si (r. contiene (e [b], este)) return 0}));! a (c = this.pushStack ([]), b = 0, b <d, b ++) r.find (a, e [b], ? c); retorno d> 1 r.uniqueSort (c): c}, filtro: la función (a) {return this.pushStack (D (esto, a || [] ,! 1))}, no: la función ( a) {return this.pushStack (D (esto, a || [] ,! 0))}, es: function (a) {return !! D (esto "cadena" == typeof a && A.test (a) ? r (a): una || [] ,! 1) .length}}); var E, F = / ^ (: \ s * (<[\ w \ w] +>) [^>] *? ! | # ([\ w -] +)) $ /, G = r.fn.init = function (a, b, c) {var e, f, si (a) se volverá esto, si (c = c | | e, "cadena" == typeof a) {if (e = "<" === a [0] && ">" === una [a.length-1] && a.length> = 3 [nula? , una, null]: F.exec (a) ,! correo electrónico || [1] && b) b || volver b.jquery (b || c) .find (a):? this.constructor (b ) .find (a), si (e [1]) {if (b = b instanceof r b [0]: b, r.merge (esto, r?.ParseHTML (e [1], b && b.nodeType b.ownerDocument || b:?! d, 0)), B.test (e [1]) && r.isPlainObject (b)) de (e en b) r.isFunction (esto [e]) esta [e] (b [e]):? this.attr (e, B [e]);} return devuelva esta f = d.getElementById (e [2]), f && (esto [ 0] = F, this.length = 1), esta} a.nodeType de retorno (esta [0] = a, this.length = 1, esto):?? r.isFunction (a) void 0 == c!. ? c.ready listo (a): una (r): r.makeArray (a, este)}; G.prototype = r.fn, E = r (d); var = H / ^ (padres ?: | prev (: Hasta | Todos?)) /, I = {hijos: 0, contenidos: 0, próxima: 0, Prev:!!!! 0}; r.fn.extend ({tiene: function (a) {var b r = (a, este), c = b.length; volver this.filter (function () {for (var a = 0; a <c; a ++) if (r.contains (esto, b [a])) return 0})}, más cercana: function (a, b) {var c, d = 0, e = this.length, f = [], g = "cadena" = typeof a && r (a); if (!!! A.test (a)) por (d <e, d ++) para (c = esta [d]; c && c == b;!? c = c.parentNode) si (c.nodeType <11 && (g g.index (c)> - 1: 1 === c.nodeType && r.find.matchesSelector (C, a))) {f.push (c);} ruptura de regreso this.pushStack (f.length> 1 r.uniqueSort (? f): f)}, índice: la función (a) {return una "cadena" == typeof un i.call (r (a), esta [0]):?? i.call (esto, a.jquery? a [0]: a): esta [0] && esta [0] .parentNode this.first () prevAll () longitud:?.. -1}, añadir: function (a, b) {return this.pushStack (r .uniqueSort (r.merge (this.get (), r (a, b))))}, addBack: function (a) {return this.add (null == un this.prevObject:? this.prevObject.filter ! (a))}}); la función J (a, b) {while ((a = a [b]) && 1 == a.nodeType); volver a} r.each ({padres: la función (a) { !? var b = a.parentNode; retorno b && 11 == b.nodeType b: null}, los padres: la función (a) {return y (a, "parentNode")}, parentsUntil: function (a, b, c) { y volver (a, "parentNode", c)}, al lado: la función (a) {return J (a, "nextSibling")}, prev: function (a) {return J (a, "previousSibling")}, nextAll : function (a) {return y (a, "nextSibling")}, prevAll: function (a) {y volver (a, "previousSibling")}, nextUntil: function (a, b, c) {return y (a , "nextSibling", c)}, prevUntil: function (a, b, c) {return y (a, "previousSibling", c)}, hermanos: function (a) {return z ((a.parentNode || { }) firstChild, a)}, los niños:. función (a) {return z (a.firstChild)}, su contenido: la función (a) {return a.contentDocument || r.merge ([], a.childNodes)} }, la función (a, b) {r.fn [a] = function (c, d) {var e = r.map (esto, b, c);! retorno "Hasta" == a.slice (-5 ) && (d = c), d && "cadena" == typeof d && (e = r.filter (d, e)), this.length> 1 && (I [a] || r.uniqueSort (e), h. el ensayo (a) && e.reverse ()), this.pushStack (e)}}); var = K / [^ \ x20 \ t \ r \ n \ f] + / g; función L (a) {var b = {}; r.each retorno (a.match (K) || [], la función (a, c) {! b [c] = 0}), b} r.Callbacks = function (a) {a = "cadena" == typeof una L (a):? r.extend ({}, a); var b, c, d, e, f = [], g = [], h = -1, i = function () {for (e = a.once, d = b = 0;! g.length; h = -1) {c = g.shift (), mientras que (++ h <f.length) f [h] .apply (c [0], c [1]) ===! 1 && && a.stopOnFalse (h = f.length, c =! 1)} || a.memory (c =! 1), b =! 1, e && (f = c []:? "")}, j = {suma: la función () {return f && (c && b && (h = f.length-1, g.push (c)), la función d (b ) {r.each (b, la función (b, c) {r.isFunction (c) a.unique && j.has (c) || ​​f.push (c):?! c && && c.length "cadena" == r. tipo (c) && d (c)})} (argumentos), c && b && i ()), esto}, remover: function () {r.each retorno (argumentos, la función (a, b) {var c; while (! (c = r.inArray (b, f, c))> - 1) f.splice (c, 1), c <= h && h -}), esta}, tiene: función (a) {return un r? .inArray (a, f)> - 1: f.length> 0}, vacío: function () {return f && (f = []), esto}, deshabilite: function () {return e = g = [], f = c = "", esto}, discapacitados: function () {return f}, cerradura: function () {retorno e = g = [], c || B || (f = c = ""), esto}, bloqueado: function () {return !! e}, fireWith: function (a, c) {return e || (c = c || [], c = [a, c.slice c.slice (? ): c], g.push (c), b || i ()), esto}, fuego: function () {return j.fireWith (este, argumentos), esto}, disparó: function () {return! ! d}}; retorno j}; función M (a) {return una función} N (a) {throw a} la función O (a, b, c) {var d; try {a && r.isFunction (d = a. ? promesa) d.call (a) .done (b) .fail (c): a && r.isFunction (d = a.then) d.call (a, b, c):? b.call (void 0, una )} catch (a) {c.call (void 0, a)}} r.extend ({diferida: la función (b) {var c = [[ "notificar", "progreso", r.Callbacks ( "memoria" ), r.Callbacks ( "memoria"), 2], [ "determinación", "hecho", r.Callbacks ( "una vez que la memoria"), r.Callbacks ( "una vez que la memoria"), 0, "resolvió"], [ "rechazar", "a prueba", r.Callbacks ( "una vez que la memoria"), r.Callbacks ( "una vez que la memoria"), 1, "rechazaron"]], d = "pendiente", e = {estado: function ( ) {return d}, siempre: function () {return f.done (argumentos) .fail (argumentos), esto}, "captura": la función (a) {return e.then (nulo, a)}, tubería: function () {var a = argumentos; volver r.Deferred (function (b) {r.each (c, la función (c, d) {var e = r.isFunction (un [d [4]]) && un [d [4]]; f [d [1]] (function () {var a = e && e.apply (este, argumentos);?. r.isFunction a && (a.promise) a.promise () curso (b.notify) .done (b.resolve) .fail (b.reject): b [d [0] + "Con"] (este, e [a]:? argumentos).})}), a = null}) promesa ( )}, entonces: function (b, d, e) {var f = 0; función g (b, c, d, e) {función de retorno () {var h = este, i = argumentos, j = function () {var a, j; (! (b <f)) {if si (a = d.apply (h, i), un c.promise === ()) throw new TypeError ( "Thenable auto-resolución") ; j = a && ( "objeto" == typeof una "función" || == typeof a) && a.then, r.isFunction (j) e j.call (a, g (F, C, M, e?? ), g (F, C, N, e)) :( f ++, j.call (a, g (F, C, M, e), g (F, C, N, e), g (f, c , h, c.notifyWith))) :( d! == M && (h = 0 nula, i = [a]), (e || c.resolveWith) (h, i))}}, k = e? j: function () {try {j ()} catch (a) {r.Deferred.exceptionHook && r.Deferred.exceptionHook (a, k.stackTrace), b + 1> f = && (d == N && (h = vacío! 0, i = [a]), c.rejectWith (h, i))}};? b k () :( r.Deferred.getStackHook && (k.stackTrace = r.Deferred.getStackHook ()), a.setTimeout (k))}} volver r.Deferred (función (a) {c [0] [3] .add (g (0, a, r.isFunction (e) e:? M, a.notifyWith)), c [1] (g (0, a, r.isFunction (b) b?: M)) [3] .add, c [2] (g [3] .add (0, a, r.isFunction (d) ?.!? d: N))}) promesa ()}, promesa: la función (a) {return null = r.extend un (a, e): e}}, f = {}; r.each retorno ( c, la función (a, b) {var g = b [2], h = b [5]; e [b [1]] = g.add, h && g.add (function () {d} = h, c [3-a] [2] .disable, c [0] [2] .lock), g.add (b [3] .fire), f [b [0]] = function () {return f [b [0] + "Con"] (esto === f void 0:? esto, argumentos), esto}, f [b [0] + "Con"] = g.fireWith}), e.promise (f) , b && b.call (f, f), f}, cuando: la función (a) {var b = arguments.length, c = b, d = array (c), e = f.call (argumentos), g = r .Deferred (), h = function (a) {función de retorno (c) {d [a] = este, e [a] = arguments.length> 1 f.call (argumentos):? c, - b || g.resolveWith (d, e)}};. si (b <= 1 && (O (a, g.done (h (c)) resolver, g.reject), "en espera" === g.state () || r.isFunction (e [c] && e [c] .then))) g.then retorno (), mientras que (c -) O (e [c], h (c), g.reject); regreso g.promise ()}}); var p = / ^ (Eval | interno | Gama | Referencia | sintaxis | Tipo | URI) Error $ /; r.Deferred.exceptionHook = function (b, c) {a.console && a. console.warn && && b P.test (b.name) && a.console.warn ( "jQuery.Deferred excepción:" + b.message, b.stack, c)}, r.readyException = function (b) {a.setTimeout (función () {} tiro b)}; var = Q r.Deferred (); r.fn.ready = function (a) {return Q.then (a) [ "atrapar"] (función (a) {r.readyException (a)}), esto}, r.extend ({isReady: 1, readyWait: 1, holdReady: function (a) {a r.readyWait ++:? r.ready (0)}, listo: function (una !?) {(una === 0 - r.readyWait: r.isReady) || (r.isReady = 0, a == 0 && - r.readyWait> 0 || Q.resolveWith (d!!! , [r]))}}), r.ready.then = Q.then; función R () {d.removeEventListener ( "DOMContentLoaded", R),
a.removeEventListener ( "carga", R), r.ready ()} "completar" === d.readyState || "carga"! == d.readyState &&! d.documentElement.doScroll? a.setTimeout (r. listo) :( d.addEventListener ( "DOMContentLoaded", R), a.addEventListener ( "carga", R)); var S = function (a, b, c, d, e, f, g) {var h = 0, i = a.length, j = null == c; si ( "objeto" === r.type (c)) {e = 0;! a (h en c) S (a, b, h, c [h] ,! 0, f, g)} else if (void 0 == d && (e = 0, r.isFunction (d) || (g = 0), j && (g? (b. llame al (a, d), b = null) :( j = b, b = function (a, b, c) {j.call retorno (r (a), c)})), b)) de (; h <i; h ++) b?? (una [h], c, g d:? d.call (una [h], h, b (a [h], c))); vuelta de correo a: j b .call (a):? i b (a [0], c): f}, T = function (a) {return 1 === === a.nodeType || 9 || a.nodeType + a! .nodeType}; función U () {this.expando = r.expando + U.uid ++} U.uid = 1, U.prototype = {cache: la función (a) {var b = a [this.expando]; b || retorno (b = {}, T (a) && (a.nodeType un [esto?. expando] = B: Object.defineProperty (a, this.expando, {valor: b, configurable: 0}))), b}, sistema: la función (a, b, c) {var d, e = esto. caché (a), si ( "cadena" == typeof b) e [r.camelCase (b)] = c; más para (d en b) e [r.camelCase (d)] = b [d]; regreso e}, obtener: la función (a, b) {return vacío 0 === b this.cache (a):? una [this.expando] && un [this.expando] [r.camelCase (b)]}, el acceso : function (a, b, c) {return vacío 0 === b || b && "cadena" == b && typeof void 0 === c this.get (a, b) :( this.set (a, b? , c), nula 0 == c c: b)}, remover:!?! función (a, b) {var c, d = a [this.expando]; si (void 0 == d) {if ( void 0 == b) {r.isArray (b) b = b.map (r.camelCase) :( b = r.camelCase (b), b = b en d [b]:?!? b.match ( K) || []), c = b.length, mientras que (c -) eliminar d [b [c]]} (void 0 === b || r.isEmptyObject (d)) && (a.nodeType ? un [this.expando] = 0 vacío: eliminar un [this.expando])}}, HasData:!! función (a) {var b = a [this.expando]; volverá vacía 0 == b && r.isEmptyObject (b)}}; var V = new U, W = new T, X = / ^: | $ / (\ {[\ w \ W] * \} \ [[\ w \ W] * \]?) !?, Y = / [AZ] / g; la función Z (a) {return "verdadero" === a || "falsa" == a && ( "nulo" === un nulo: una === + a + "" + a: X.test (a) JSON.parse (a):?? a)} function $ (a, b, c) {var d; si (void 0 === === c && 1 a.nodeType ) si (d = "datos -" + b.replace (y, "- $ &"). toLowerCase (), c = a.getAttribute (d), "cadena" == typeof c) {try {c = Z (c)} catch (e) {} W.set (a, b, c)} else c = 0 nula; devuelva c} r.extend ({HasData: function (a) {return W.hasData (a) | | V.hasData (a)}, de datos: (a, b, c) {return W.access (a, b, c)}, REMOVEDATA: función (a, b) {W.remove (a, b) }, _ de datos: (a, b, c) {return V.access (a, b, c)}, _ REMOVEDATA: función (a, b) {V.remove (a, b)}}), r.fn .extend ({datos: function (a, b) {var c, d, e, f = esta [0], g = f && f.attributes; si (void 0 === a) {if (this.length && (e = W.get (f), 1 === f.nodeType && V.get (f, "hasDataAttrs"))) {c = g.length;!, mientras que (c -) g [c] && (d = g [c] .name, 0 === d.indexOf ( "datos -") && (d = r.camelCase (d.slice (5)), $ (f, d, e [d]))); V .set (f, "hasDataAttrs", 0)} "objeto" de retorno e} == retorno typeof un this.each (function () {W.set (esto, a)}):? S (esto, la función ( b) {var c; si (f && vacío 0 === b) {if (c = W.get (f, a), nula 0 == c) c retorno; if (! c = $ (f, a), 0 vacío! == c) retorno c} else this.each (function () {W.set (esto, a, b)})}, null, b, arguments.length> 1, null, 0)}, REMOVEDATA: function (a) {return this.each (function () {W.remove (esto, a)})}}), r.extend ({cola: la función (a, b, c) {var d; si (a) la devolución b = (b || "FX") + "cola", d = V.get (a, b), c && (! d || r.isArray (c)? d = V.access (una , b, r.makeArray (c)): d.push (c)), d || []}, quitar de la cola: la función (a, b) {b = b || "fx"; var c = r.queue (a, b), d = c.length, e = c.shift (), f = r._queueHooks (a, b), g = function () {r.dequeue (a, b)}; "inprogress" === e && (e = c.shift (), d -), e && ( "FX" === b && c.unshift ( "inprogress"), eliminar f.stop, e.call (a, g, f) ) ,! d && && f f.empty.fire ()}, _ queueHooks: function (a, b) {var c = b + "queueHooks"; return V.get (a, c) || ​​V.access (a, c, {vacía :. r.Callbacks ( "una vez que la memoria") se suman (function () {V.remove (a, [b + "cola", c])})})}}), r.fn.extend ({cola: la función (a, b) {var c = 2;!? volver "cadena" = typeof a && (b = a, a = "FX", c -), arguments.length <c r.queue (esto [0], ? a): void 0 === b esto: this.each (function () {var c = r.queue (esto, a, b); r._queueHooks (esto, a), "fx" === a && "InProgress" == c [0] && r.dequeue (esto, a)})}, quitar de la cola: la función (a) {return this.each (function () {r.dequeue (esto, a)})}, clearQueue: function (a) {return this.queue (a || "FX", [])}, promesa: la función (a, b) {var c, d = 1, e = r.Deferred (), f = esto, g = this.length, h = function () {- d || e.resolveWith (f, [f])}; "cadena" = typeof a && (b = a, a = 0 nula), una! = a || "FX", mientras que (g -) c = V.get (f [g], "+" queueHooks a), c && && c.empty (d ++, c.empty.add (h)); h retorno ( ), e.promise (b)}}); var _ = / [+ -] (: \ d * \ |) \ d + (: [eE] [+ -] \ d + |) /??.?. fuente, aa = new RegExp ( "^ (?: ([+ -]) = |) (" + _ + ") ([az] *%) $", "i"), BA = [ "Inicio", , "inferior" "derecha", "izquierda"], ca = function (a, b) {return a = b || a, "ninguno" === a.style.display || "" === a. style.display && r.contains (a.ownerDocument, a) && "ninguna" === r.css (un "display")}, da = function (a, b, c, d) {var e, f, g = {}; a (f en b) g [f] = a.style [f], a.style [f] = b [f]; e = c.apply (a, d || []), porque (f en b) a.style [f] = g [f]; retorno e};? ea función (a, b, c, d) {var e, f = 1, g = 20, h = d función ( ) {return d.cur ()}: function () {return r.css (a, b, "")}, i = h (j) = c, c && [3] || (r.cssNumber [b]? "": "px"), k = (r.cssNumber [b] || "! px" == j && + i) && aa.exec (r.css (a, b)); si (k && k [3]! == j) {j = j || k [3], c = c || [], k = i + 1 ||; hacer f = f || "0.5", k / f =, r.style (a, b, k + j), mientras que (! f == (f = h () / i) && 1 == f && - g)} return c && (k = k + || + i || 0, e = c [1] k + (c [1] 1) * c [2]:? + c [2], d && (d.unit = j, k = d.start, d.end = e)), e} var fa = {}; ga función (a) {var b, c = a.ownerDocument, d = a.nodeName, e = f bis [d]; vuelta de correo electrónico: (b = c.body.appendChild (? c.createElement (d)), e = r.css (b, "display"), b.parentNode.removeChild (b), "ninguna" === e && (e = "bloque"), fa [d] = e, e)} function ha (a, b) {for (var c, d, e = [], f = 0, g = a.length; f <g; f ++) d = a [f], d. estilo && (c = d.style.display, b? ( "ninguno" === c && (e [f] = V.get (d, "pantalla") || nulo, e [f] || (d.style .display = "")) "," === d.style.display && ca (d) && (e [f] = ga (d))): "ninguna" == c && (e [f] = "none ", V.set (d," pantalla ", c))); for (f = 0; f <g;! f ++) null = e [f] && (a [f] .style.display = e [f ]); volver a} r.fn.extend ({espectáculo: function () {return ha (esto, 0)}, ocultar: function () {return ha (este)}, de palanca: la función (a) {return "booleano" == typeof a a this.show ():?? this.hide (): this.each (function () {ca (esto) r (este) .show) (:? r (este) .hide ()})}}); var ia = / ^ (casilla ?: | radio) $ / i, ja = / <([az] [^ \ / \ 0> \ x20 \ t \ r \ n \ f] +) / i, ka = / ^ $ | \ / (java ?: | ECMA) script / I, Ia = {opción: [1, "<select múltiple '' múltiples =>", "</ select>"] , culata en T: [1, "<table>", "</ table>"], col: [2, "<table> <colgroup>", "</ colgroup> </ table>"], tr: [2 "<table> <tbody>", "</ tbody> </ table>"], td: [3, "<table> <tbody> <tr>", "</ tr> </ tbody> </ table> "], _ por defecto: [0," "," "]}; la.optgroup = la.option, la.tbody = = la.tfoot la.colgroup = = la.caption la.thead, la.th = la.td; ma función (a, b) {var c; c = retorno "indefinido" = typeof a.getElementsByTagName a.getElementsByTagName (b || "*"):!?! "indefinido" = typeof a.querySelectorAll? a.querySelectorAll (b || "*"): [], nula 0 === b || && b r.nodeName (a, b) r.merge ([a], c):? c} function na (a, b) {for (var c = 0, d = a.length; c <d;! c ++) V.set (a [c], "globalEval", b || V.get (b [c], "globalEval "))} var OA = / <| & # \ w +; /; pa función (a, b, c, d, e) {for (var f, g, h, i, j, k, l = b .createDocumentFragment (), m = [], n = 0, o = a.length; n <O; n ++) si (f = a [n], f || 0 === f) si ( "objeto" = == r.type (f)) r.merge (m, f.nodeType [f]:? f); else if (oa.test (f)) {g = g || l.appendChild (b.createElement ( "div")), h = (ja.exec (f) || [ "", ""]) [1] .tolowercase (), i = la [h] || la._default, g.innerHTML = i [1] + r.htmlPrefilter (f) + i [2], k = i [0], mientras que (k -) g = g.lastChild; r.merge (m, g.childNodes), g = l. firstChild, g.textContent = ""} else m.push (b.createTextNode (f)); l.textContent = "", n = 0; while (f = m [n ++]) si (d && r.inArray (f, d)> - 1) e && e.push (f); else if (j = r.contains (f.ownerDocument, f), g = ma (l.appendChild (f), "script"), j && na (g), c) {k = 0; while (f = g [k ++]) ka.test (f.type || "") && c.push (f)}! retorno l} function () {var a = d.createDocumentFragment ( ), b = a.appendChild (d.createElement ( "div")), c = d.createElement ( "entrada"); c.setAttribute ( "tipo", "radio"), c.setAttribute ( "verificado", "controlada"), c.setAttribute ( "nombre", "t"), b.appendChild (c), o.checkClone = b.cloneNode (0) .cloneNode (0) .lastChild.checked, b.innerHTML = "<textarea> x </ textarea>", o.noCloneChecked = !! b.cloneNode .lastChild.defaultValue} () (0); var = qa d.documentElement ra = / ^ tecla /, sa = / ^ (ratón ?: | puntero | contextual | arrastre | gota) | pulse /, ta = / ^ ([^.] *) (:?.. \ (+) |)! /; ua función () {return 0 } la función VA () {directo volver 1} wa función () {try {return d.activeElement} catch (a) {}} la función xa (a, b, c, d, e, f) {var g, h; si ( "objeto" == typeof b) { "cadena" = typeof c && (d = d || c, c = 0 nula);! a (h en b) xa (a, h, c, d, b [ h], f); volver a} Si (null && d == == nula e (e = c, d = c = 0 vacío?): null == e && ( "cadena" == c typeof (e = d,? d = 0 nula) :( e = d, d = c, c = 0 nula)), e === 1) e = VA;! else if (e) volver a; regreso (g 1 === f && = e, e = función (a) {return r (). off (a), g.apply (esto, argumentos)}, e.guid = g.guid || (g.guid = r.guid ++)), a.each (function () {r.event.add (esto, b, e, d, c)})} = {r.event mundial: {}, añadir: function (a, b, c, d, e ) {var f, g, h, i, j, k, l, m, n, o, p, q = V.get (a), si (q) {c.handler && (f = c, c = f .handler, e = f.selector), e && r.find.matchesSelector (qa, e), c.guid || (c.guid = r.guid ++), (i = q.events) || (i = q. eventos = {}), (g = q.handle) || (g = q.handle = function (b) {return "indefinido"! = typeof r.event r && r.event.triggered! == b.type?. dispatch.apply (a, argumentos): void 0}), b = (b || "".) partido (K) || [ ""], j = b.length, mientras que (j -) h = ta .exec (b [j]) || [], n = p = h [1], o = (h [2] || ""). split ( "."). sort (), n && (l = r.event.special [n] || {}, n = (e l.delegateType:? l.bindType) || n, l = r.event.special [n] || {}, k = r.extend ({tipo n, origType: p, los datos: d, manejador: c, GUID: c.guid, selector de: e, needsContext: e && r.expr.match.needsContext.test (e), espacio de nombres: o.join ( " . ")}, f), (m = i [n]) || (m = i [n] = [], m.delegateCount = 0, l.setup && l.setup.call (a, d, o, g )! ==! 1 || a.addEventListener && a.addEventListener (n, g)), l.add && (l.add.call (a, k), k.handler.guid || (c = k.handler.guid .guid)), e m.splice (m.delegateCount ++, 0, k):?! m.push (k), r.event.global [n] = 0)}}, remover: function (a, b, c, d, e) {var f, g, h, i, j, k, l, m, n, o, p, q = V.hasData (a) && V.get (a), si (q && (i = q.events)) {b = (b || "") partido (K) ||. [ ""], j = b.length, mientras que (j -) si (h = ta.exec (b [ j]) || [], n = p = h [1], o = (h [2] || ""). split ( "."). sort (), n) = {l r.event. especial [n] || {}, n = (d l.delegateType:? l.bindType) || n, m = i [n] || [], h = h [2] && nueva RegExp ( "(^ | \\) "+ o.join (" \\ (:.?.. * \\ |).. ") +" (\\ | $) "), g = f = m.length, mientras que (f- -!!!!) k = m [f] ,! e && p == k.origType || c && c.guid == k.guid || h && h.test (k.namespace) || d && d == k.selector && ( !! "**" == d || k.selector) || (m.splice (f, 1), k.selector && m.delegateCount -, l.remove && l.remove.call (a, k)); g && ! m.length && (l.teardown && l.teardown.call (a, o, q.handle)! ==! 1 || r.removeEvent (a, n, q.handle), borrar i [n])} else para (n en i) r.event.remove (a, n + b [j], c, d, 0); r.isEmptyObject (i) && V.remove (a, "manejar eventos")}}, de expedición: la función (a) {var b = r.event.fix (a), c, d, e, f, g, h, i = new array (arguments.length), j = ((V.get esto ", eventos ") || {}) [b.type] || [], k = r.event.special [b.type] || {}; for (i [0] = b, c = 1; c <argumentos .length; c ++) i [c] = argumentos [c]; si (= b.delegateTarget esto, k.preDispatch || k.preDispatch.call (esto, b!) == 1) {h = r!!. event.handlers.call (esto, b, j), c = 0; while ((f = h [C ++]) && b.isPropagationStopped ()) {b.currentTarget = f.elem, d = 0; while ( (g = f.handlers [d ++]) &&! b.isImmediatePropagationStopped ()) b.rnamespace &&! b.rnamespace.test (g.namespace) || (b.handleObj = g, B.Data = g.data, e = ((r.event.special [g.origType] || {}). || manejar g.handler) .apply (f.elem, i), nula 0 == e && (b.result = e) = ! == 1 && (b.preventDefault (), b.stopPropagation ()))} return k.postDispatch && k.postDispatch.call (esto, b), b.result}}, manipuladores: function (a, b) {var c , d, e, f, g, h = [], i = b.delegateCount, j = a.target; if (! i && && j.nodeType ( "clic" === a.type && a.button> = 1)) para (;! j == esto; j = || j.parentNode esto) si {for (1 === j.nodeType && ( "clic" == || a.type j.disabled == 0)!!!) (f = [], g = {}, c = 0; c <i; c ++) d = b [c], e = d.selector + "", nula 0 === g [e] && (g [e ?.] = d.needsContext r (e, esto) .index (j)> - 1: r.find (e, este, null, [j]) de longitud), g [e] && f.push (d); f.length && h.push ({elem: j, manipuladores: f})} j = retorno de esto, i <&& b.length h.push ({elem: j, manipuladores: b.slice (i)}), h}, addProp : function (a, b) {Object.defineProperty (r.Event.prototype, a, {enumerables: 0, configurable: 0, obtener:? r.isFunction (b) la función () {if (this.originalEvent) b retorno (this.originalEvent)}: function () {if (this.originalEvent) this.originalEvent volver [a]}, sistema: función (b) {Object.defineProperty (esto, a, {enumerables: 0, configurable : 0, se puede escribir: 0, valor: b})}})}, fijar: la función (a) {return un [r.expando] a:? r.Event nuevo (a)}, especial: {carga: {noBubble: 0}, se centran: {gatillo: function () {if (! == esta wa () && this.focus) volver this.focus () ,! 1}, delegateType: "focusin"}, falta de definición: { gatillo: function () {if (esto === wa () && this.blur) volver this.blur () ,! 1}, delegateType: "focusOut"}, haga clic en: {gatillo: function () {if casilla ( " "=== this.type && && this.click r.nodeName (esto" entrada ")) volver this.click () ,! 1}, _ por defecto: la función (a) {return r.nodeName (a.target," a ") }}, beforeunload: {postDispatch: la función (a) {void 0 == a.result && && a.originalEvent (a.originalEvent.returnValue = a.result)}}}}, r.removeEvent = function (a, b, c ) {a.removeEventListener && a.removeEventListener (b, c)}, r.Event = function (a, b) {return este instanceof r.Event? (a && a.type? (this.originalEvent = a, this.type = a. tipo, this.isDefaultPrevented = || a.defaultPrevented vacío 0 === === a.defaultPrevented && a.returnValue 1 UA:?!? VA, this.target = a.target && 3 === a.target.nodeType a.target .parentNode: a.target, this.currentTarget = a.currentTarget, this.relatedTarget = a.relatedTarget): this.type = a, b r.extend && (esto, b), this.timeStamp = a && a.timeStamp || r. ahora (), nula (esto [r.expando] = 0)): nueva r.Event (a, b)}, {r.Event.prototype = constructor: r.Event, isDefaultPrevented: VA, isPropagationStopped: VA, isImmediatePropagationStopped: VA, isSimulated: 1, preventDefault: {! var a = this.originalEvent; this.isDefaultPrevented = ua, a && && this.isSimulated a.preventDefault ()} function (), stopPropagation: function () {var a = esto. ! originalEvent; this.isPropagationStopped = ua, a && && this.isSimulated a.stopPropagation ()}, stopImmediatePropagation: function () {var a = this.originalEvent; this.isImmediatePropagationStopped = ua, a && && this.isSimulated a.stopImmediatePropagation (), esto. stopPropagation ()}}, r.each ({altKey: 0, burbujas: 0, cancelables:! 0, changedTouches: 0, ctrlKey: 0, detalle: 0, eventPhase: 0, metakey: 0 , pageX: 0, pageY: 0, shiftKey: 0, vistas: 0, "char": 0, charCode: 0, tecla: 0, keyCode: 0, un botón: 0, botones: 0, clientX: 0, clientY: 0, offsetX: 0, offsetY: 0, pointerId: 0, pointerType: 0, screenX: 0, screenY: 0, targetTouches: 0, toElement: 0, toca: 0, que:!?!? función (a) {var b = a.button; volver == null && a.which ra.test (a.type) null = a.charCode a.charCode: a. keyCode:!? a.which && vacío 0 == b && sa.test (a.type) 1 & b 1: 2 y 3 b:? 4 & b 2: 0: a.which}}, r.event.addProp), r.each ( {MouseEnter: "mouseover", mouseleave: "mouseout", pointerenter: "pointerover", pointerleave: "pointerout"}, la función (a, b) {r.event.special [a] = {delegateType: b, bindType: b , manejar: la función (a) {var, c, d = este, e = f = a.relatedTarget a.handleObj; e volver && (e === d || r.contains (d, e)) || (una .type = f.origType, c = (f.handler.apply esto, argumentos), a.type = b), c}}}), r.fn.extend ({on: function (a, b, c, d) {xa retorno (esto, a, b, c, d)}, uno: la función (a, b, c, d) {xa retorno (esto, a, b, c, d, 1)}, apagado: la función (a, b, c) {var d, e; si (a && && a.preventDefault a.handleObj) de retorno d = a.handleObj, r (a.delegateTarget) .OFF (d.namespace d.origType + d +? "." .namespace: d.origType, d.selector, d.handler), esto, si ( "objeto" == typeof a) {for (e en a) this.off (e, b, a [e]); regreso este retorno b}! ==! 1 && "función"! = typeof b || (c = b, b = 0 nula), c ===! 1 && (c = VA), this.each (function () {r .event.remove (esto, a, c, b)})}}); var ya = / <(?! área | br | col | embed | h | img | entrada | enlaces | meta | param) (([ az] [^ \ / \ 0> \ x20 \ t \ r \ n \ f] *) [^>] *) \ /> / gi, za = / <script | <style | <link / i, Aa = / comprobado \ s *: | / i, Ba = / ^ verdadera \ / (*.) /, Ca = / ^ \ s * <(([^ =] = \ s * .checked?.):? \ [CDATA \ [| -) | (?: \] \] | -)> \ s * $ / g; función Da (a, b) {return r.nodeName (una "mesa",) && r.nodeName (! == 11 b.nodeType b:? b.firstChild, "tr")? a.getElementsByTagName ( "tbody") [0] || a: una función} Ea (a) {return a.type = (null ! == a.getAttribute ( "tipo")) + "/" + a.type, una función} Fa (a) {var b = Ba.exec (a.type); b retorno a.type = b [ 1]: a.removeAttribute ( "tipo"), una función} Ga (a, b) {var c, d, e, f, g, h, i, j; si (1 === b.nodeType) { si (V.hasData (a) && (f = V.access (a), g = V.set (b, f), j = f.events)) {delete g.handle, g.events = {}; para (e en la j) para (c = 0, j = d [e] .length; c <d, c ++) r.event.add (b, e, j [e] [c])} W.hasData ( a) && (h = W.access (a), i = r.extend ({}, h), W.set (b, i))}} function Ha (a, b) {var c = b.nodeName ?! .tolowercase (); "entrada" === c && ia.test (a.type) b.checked = a.checked: == c && "área de texto" "entrada" == || c (= a b.defaultValue .defaultValue)} function Ia (a, b, c, d) = {b g.apply ([], b); var e, f, h, i, j, k, l = 0, m = a.length , n = m-1, q = b [0], s = r.isFunction (q); if (! s || m> 1 && "cadena" == typeof q && && o.checkClone Aa.test (q)) devuelve una each (function (e) {var f = A.EQ (e); s && (b [0] = q.call (esto, e, f.html ())), Ia (f, b, c, d )}); if (! m && (e = pa (b, a [0] .ownerDocument, 1, a, d), f = e.firstChild, 1 === e.childNodes.length && (e = f), f || d)) {for (h = r.map (ma (e, "script"), Ea), i = h.length; l <m;! l ++) j = e, l == n && (j = r.clone (j, 0, 0!), i && r.merge (h, MA (j, "script"))), c.call (a [l], j, l), si (i) para (k = h [h.length-1] .ownerDocument, r.map (h, Fa), l = 0; l <i; l ++) j = h [l], ka.test (j.type || " ") && V.access (j," globalEval ") && r.contains (k, j) && (j.src r._evalUrl && r._evalUrl (j.src?): p (j.textContent.replace (Ca" "), k))}} devuelve una función de Ja (a, b, c) {for (var d, e = b r.filter (b, a):? a, f = 0; null = (d =! e [f]);! f ++) c || 1 || == d.nodeType r.cleanData (ma (d)), d.parentNode && (c && r.contains (d.ownerDocument, d) && na (ma (d, "script")), d.parentNode.removeChild (d));} devuelve un r.extend ({htmlPrefilter: function (a) {a.replace retorno (ya, "<$ 1> </ $ 2>")}, (0): clon! función (a, b, c) {var d, e, f, g, h = a.cloneNode, i = r.contains (a.ownerDocument, a); if ((o.noCloneChecked || 1! == a.nodeType && 11! == || a.nodeType r.isXMLDoc (a))) de (g = ma (h), F = ma (a), d = 0, e = f.length ; d <e, d ++) Ha (f [d], g [d]); si (b) si (c) para (ma f = f || (a), g = g || ma (h), d = 0, e = f.length; d <e, d ++) Ga (f [d], g [d]); lo demás Ga (a, h); retorno g = ma (h, "script"), g .length> 0 && na (! g, i && ma (un "script")), h}, CleanData: function (a) {for (var b, c, d, e = r.event.special, f = 0; void 0 == (c = a [f]); f ++) si (T (c)) {if (b = c [V.expando]) {if (b.events) para (d en b.events) e [d] r.event.remove (c, d):? r.removeEvent (c, d, b.handle); c [V.expando] = 0} void c [W.expando] && (c [W. expando] = 0 void)}}}), r.fn.extend ({separar: la función (a) {return Ja (esto, a, 0)}, remover: la función (a) {return Ja (esto, una )}, el texto: la función (a) {return S (esto, la función (a) {return vacío 0 === una R.TEXT (este):?.! this.empty () cada uno (function () {1 = !! = this.nodeType && 11 && 9 == == this.nodeType this.nodeType || (this.textContent = a)})}, null, una, arguments.length)}, anexar: function () {return Ia (este, argumentos, la función (a) {if (1 === === this.nodeType || 11 || 9 this.nodeType === this.nodeType) {var b = Da (esto, a); b.appendChild ( a)}})}, anteponga: function () {return Ia (esto, los argumentos, la función (a) {if (1 === === this.nodeType || 11 || 9 this.nodeType === este .nodeType) {var b = Da (esto, a); b.insertBefore (a, b.firstChild)}})}, antes: function () {return Ia (esto, los argumentos, la función (a) {this.parentNode && este .parentNode.insertBefore (a, este)})}, después: function () {return Ia (esto, los argumentos, la función (a) {this.parentNode && this.parentNode.insertBefore (a, this.nextSibling)})}, vacío : function () {for (! var a, b = 0; null = (a = esta [b]); b ++) 1 === a.nodeType && (r.cleanData (ma (a, 1)), una .textContent = "");} devuelva este, clon: función: {r retorno (a, b) {return null = a = a && a, b = null == b a b, this.map (function (!?). clone (esto, a, b)})}, html: function (a) {return S (esto, la función (a) {var b = esta [0] || {}, c = 0, d = this.length y si (void 0 === === a && 1 b.nodeType) b.innerHTML regresar;! if (! "cadena" == typeof a && za.test (a) && la [(ja.exec (a) || [ "", ""]) [1] .tolowercase ()]) {a = r.htmlPrefilter (a); try {for (; c <d, c ++) b = esta [c] || {}, 1 === b.nodeType && (r.cleanData (ma (b, 1)), b.innerHTML = a!);. b = 0} catch (e) {}} b && this.empty () append (a)}, null, una, arguments.length)}, Vuelvaa: function () {var a = []; volver Ia (esto, los argumentos, la función (b) {var c = this.parentNode; r.inArray (esto, a) < 0 && (r.cleanData (ma (este)), c && c.replaceChild (b, este))}, a)}}), r.each ({appendTo: "añadir", Prefijopara: "anteponer", insertBefore: "antes ", InsertAfter:" después ", replaceAll:" Vuelvaa "}, la función (a, b) {r.fn [a] = function (a) {for (var c, d = [], e = r (a) , f = e.length-1, g = 0; g <= f; g ++) c = g === f esto:?! this.clone (0), r (e [g]) (c [b] ), h.apply (d, c.get ()); return this.pushStack (d)}}); var = Ka / ^ margen /, = La nueva RegExp ( "^ (" + _ + ") (? ! px) [az%] + $ "," i "), Ma = function (b) {var c = b.ownerDocument.defaultView; return c && || c.opener (c = a), c.getComputedStyle (b) ;!} function () {b función () {if (i) {i.style.cssText = "caja de dimensionamiento: frontera de la caja; position: relative; display: block; margen: auto; frontera: 1px; padding: 1px; superior: 1%; anchura: 50% ", i.innerHTML =" ", qa.appendChild (h); var b = a.getComputedStyle (i); c =" 1% "== b.top,! g = "2px" === b.marginLeft, e = "4PX" === b.width, i.style.marginRight = "50%", f = "4PX" === b.marginRight, qa.removeChild (h), i = null}} var c, e, f, g, h = d.createElement ( "div"), i = d.createElement ( "div"); i.style && (i.style.backgroundClip = "El contenido de la caja", i.cloneNode (0) .style.backgroundClip = "", o.clearCloneStyle = "Content-box" === i.style.backgroundClip, h.style.cssText = "border: 0; anchura: 8 píxeles; altura: 0; top: 0; left: -9999px; padding: 0; margin-top: 1px; position: absolute ", h.appendChild (i), r.extend (o, {pixelPosition: function ( ) {return b (), c}, boxSizingReliable: function () {return b (), e}, pixelMarginRight: function () {return b (), f}, reliableMarginLeft: function () {return b (), g }}))} (); función de Na (a, b, c) {var d, e, f, g, h = a.style; retorno c = c || Ma (a), c && (g = c. getPropertyValue (b) || c [b] ","! == g || r.contains (a.ownerDocument, a) || (g = r.style (a, b)) ,! o.pixelMarginRight () && La.test (g) && Ka.test (b) && (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = = h.maxWidth h.width = g, g = c. anchura, h.width = d, h.minWidth = e, h.maxWidth = f)), nula 0 == g g + "":!? g} function Oa (a, b) {return {get: function () {return un () void borrar this.get:? (this.get = b) .apply (esto, argumentos)}}} var = Pa / ^ (?!. ninguno | mesa (- c [EA]) +) /, Qa = {position: "absoluta", la visibilidad: "oculta", la pantalla: "bloque"}, Ra = {letterSpacing: "0", fontWeight: "400"}, S = [ "Webkit", "Moz" , "ms"], Ta = d.createElement ( "div") estilo;. funcione Ua (a) {if (una en Ta) de regreso a; var b = a [0] .toUpperCase () + a.slice ( 1), c = Sa.length; while (c -) si (a = Sa [c] + b, a en Ta) volver a} función Va (a, b, c) {var d = aa.exec ( b); d Math.max de retorno (0, d [2] - (c || 0)) + (d [3] || "px"):? b} function Wa (a, b, c, d, e) {var f, g = 0; para (f = c === (d "frontera": "contenido")? 4: "anchura" b === 1: 0; f <4; f + = 2) "margen" === c && (g + = r.css (a, c + b bis [f] ,! 0, e)), d? ( "contenido" === c && (g- = r.css ( un "relleno" + ba [f] ,! 0, e)), "margen"! == c && (g- = r.css (una "frontera" + ba [f] + "Ancho", 0 , e))) :( + g = r.css (un "relleno" + ba [f] ,! 0, e), "relleno"! == c && (g + = r.css (una "frontera" + ba [f] + "Ancho", 0, e)));! retorno g} function Xa (a, b, c) {var d, e = 0, F = ma (a), g = "frontera- cuadro "=== r.css (a," boxSizing ", 1, f!);. Si (a.getClientRects () && longitud (d = a.getBoundingClientRect () [b]), d <= 0 || nula == d) {if (d = Na (a, b, f), (d <0 || nula == d) && (d = a.style [b]), La.test (d)) de retorno d ; e = g && (o.boxSizingReliable () || d === a.style [b]), d = parseFloat (d) || 0} return d + Wa (a, b, c || (g "? frontera ":" contenido "), e, f) +" px "} {r.extend (cssHooks: {opacidad: {get: function (a, b) {if (b) {var c = Na (a," opacidad "); return" "=== C" 1 ":?!!!!! c}}}}, cssNumber: {animationIterationCount: 0, columnCount: 0, fillOpacity: 0, flexGrow: 0, flexShrink: 0, fontWeight: 0, lineHeight: 0, la opacidad: 0, orden:! 0, huérfanos: 0, viudas: 0, zIndex: 0, zoom: 0}, cssProps: { "flotar": "cssFloat "}, el estilo: la función (a, b, c, d) {if (! a && 3 == == 8 a.nodeType && && a.nodeType a.style) {var e, f, g, h = r.camelCase (b) , i = a.style; b = retorno r.cssProps [h] || (r.cssProps [h] = Ua (h) || h), g = r.cssHooks [b] || r.cssHooks [h ], nula 0 === c && g "llegar" en g && vacío 0 == (e = g.get (a, 1, d)!) e:?!? i [b] :( f = typeof c, "string "=== f && (e = aa.exec (c)) && e [1] && (c = ea (a, b, e), f =" número "),! = c && C === C && (nulo" número "=== f && (c + e = && e [3] || (r.cssNumber [h]?" ":" px "))!, o.clearCloneStyle ||" "== == 0 c || b!. indexOf ( "fondo") || (i [b] = "heredar"), g && "set" en g && void 0 === (c = g.set (a, c, d)) || (i [b] = c)), nula 0)}}, css: function (a, b, c, d) {var e, f, g, h = r.camelCase (b); b = retorno r.cssProps [h] | | (r.cssProps [h] = Ua (h) || h), g = r.cssHooks [b] || r.cssHooks [h], g && "llegar" en g && (e = g.get (a, 0, c)), nula 0 === e && (e = Na (a, b, d)), "normal" === e && b en Ra && (e = Ra [b]), "" === C ? || c (f = parseFloat (e), c === 0 || isFinite (f) f || 0:? e): e}}), r.each ([ "altura", "ancho" ], la función (a, b) {r.cssHooks [b] = {get: function (a, c, d) {if (c) devuelven Pa.test (r.css (un "display")) |! ..? | a.getClientRects () && longitud a.getBoundingClientRect () ancho Xa (a, b, d): da (a, control de calidad, la función () {return Xa (a, b, d)})}, sistema: función (a, c, d) {var e, f = d && Ma (a), g = d && Wa (a, b, d, "frontera-box" === r.css (a, "boxSizing",! 1, f ), f);! retorno g && (e = aa.exec (c)) && "px" == (e [3] || "px") && (a.style [b] = c, c = r. css (a, b)), Va (a, c, g)}}}), r.cssHooks.marginLeft = Oa (o.reliableMarginLeft, la función (a, b) {if (b) de retorno (parseFloat (Na ( un "marginLeft")) || a.getBoundingClientRect () izquierda-da (a, {marginLeft: 0}., la función () {return a.getBoundingClientRect () izquierdo.})) + "px"}), r each ({margin: "", padding: "", en la frontera: "Ancho"}, la función (a, b) {r.cssHooks [a + b] = {ampliar: function (c) {for (var d = 0, e = {}, f = "cadena" == typeof c c.split ( ""):? [c]; d <4; d ++) e [a + b bis [d] + b] = f [d ] || f [D-2] || f [0]; regresar e}}, Ka.test (a) || (r.cssHooks [a + b] .set = Va)}), r.fn. extender ({css: function (a, b) {return S (esto, la función de (a, b, c) {var d, e, f = {}, g = 0, si (r.isArray (b)) { para (d = Ma (a), e = b.length; g <e, g ++) f [b [g]] = r.css (a, b [g] ,! 1, d); retorno f} return void 0 == c r.style (a, b, c):? r.css (a, b)}, a, b, arguments.length> 1)}}); función Ya (a, b, c , d, e) {return new Ya.prototype.init (a, b, c, d, e)} = r.Tween Ya, Ya.prototype = {constructor: Ya, init: function (a, b, c, d, e, f) = {this.elem una, this.prop = c, this.easing = e || r.easing._default, this.options = b, this.start = = this.now this.cur ( ), this.end = d, this.unit = f || (r.cssNumber [c] "": "px")}, cur: function () {var a = Ya.propHooks [this.prop]; volver a && a.get a.get (este): Ya.propHooks._default.get (este)}, ejecute: function (a) {var b, c = Ya.propHooks [this.prop]; this.options volver?. ? duración this.pos = b = r.easing [this.easing] (a, this.options.duration * a, 0,1, this.options.duration): this.pos = b = a, this.now = (this.end-this.start) * b + this.start, this.options.step && this.options.step.call (this.elem, this.now, este), c && c.set c.set (esto)?: Ya.propHooks._default.set (este), esto}}, Ya.prototype.init.prototype = Ya.prototype, Ya.propHooks = {_ defecto: {get: la función (a) {var b, y devuelve 1 == a.elem.nodeType || nula! = a.elem [a.prop] && nula == a.elem.style [a.prop]? a.elem [a.prop] :( b = r.css (a. ! elem, a.prop, ""), b && "auto" == b b:? 0)}, sistema:? la función (a) {r.fx.step [a.prop] r.fx.step [a .prop] (a):!? 1 == == a.elem.nodeType || nula a.elem.style [r.cssProps [a.prop]] && r.cssHooks [a.prop] a.elem [a.prop] = a.now: r.style (a.elem, a.prop, a.now + a.unit)}}}, Ya.propHooks.scrollTop = Ya.propHooks.scrollLeft = {sET: función (a) {a.elem.nodeType && && a.elem.parentNode (a.elem [a.prop] = a.now)}}, {r.easing = lineal: función (a) {return a}, columpio: function ( a) {return.5-Math.cos (a * Math.PI) / 2}, _ por defecto: "swing"}, r.fx = Ya.prototype.init, r.fx.step = {}; var Za, $ a, _a = / ^ (?: basculante | mostrar | ocultar) $ /, = ab / queueHooks $ /; bb function () {$ a && (a.requestAnimationFrame (bb), r.fx.tick ())} cb función () {return a.setTimeout (function () {Za = 0} void), Za = r.now ()} function db (a, b) {var c, d = 0, e = {height: una }; para (b = b 1: 0; d <4; d + = 2-b) c = ba [d], e [ "margen" + c] = e [ "relleno" + c] = a; regreso (e.opacity = = e.width a) e} function b &&, EB (a, b, c) {for (var D, e = (hb.tweeners [b] || []). concat (hb.tweeners [ "*"]), f = 0, g = e.length; f <g; f ++) si (d = e [f] .call (c, b, a)) de retorno d} function fb (a, b , c) {var d, e, f, g, h, i, j, k, l = "ancho" en b || "altura" en b, m = este, n = {}, o = a.style , p = a.nodeType && ca (a), q = V.get (a, "fxshow"); c.queue || (g = r._queueHooks (a, "FX"), == null g.unqueued && (g .unqueued = 0, h = g.empty.fire, g.empty.fire = function () {g.unqueued || h ()}), g.unqueued ++, m.always (function () {m.always ( {. g.unqueued -, r.queue (a, "FX") de longitud || g.empty.fire ()} function ())})), porque (d en b) si (e = b [d ], _ a.test (e)) {if (b eliminar [d], f = f || "cambiar" === e, e === (p "ocultar": "mostrar")) {if ( "espectáculo" == || e || q vacío 0 === q [d]) continuará;!!! p = 0} n [d] = q && q [d] || r.style (a, d)} si (i =! r.isEmptyObject (b), i ||! r.isEmptyObject (n)) {l && 1 === a.nodeType && (c.overflow = [o.overflow, o.overflowX, o.overflowY], j = q && q.display, null && == j (j = V.get (un "display")), k = r.css (un "display"), "ninguna" === k && (j? k = j: (ja ([a] ,! 0), j = a.style.display || j, k = r.css (un "display"), ha ([a]))), ( "en línea" === k || "inline-block" === k && nula! = j) && "ninguna" === r.css (a, "flotar") && (i || (m.done (function () { o.display = j}), null == j && (k = o.display, j = "none" === k "?": k)), o.display = "inline-block")), c. desbordamiento && (o.overflow = "oculto", m.always (function () {o.overflow = c.overflow [0], o.overflowX = c.overflow [1], o.overflowY = c.overflow [2] !?})), i = 1, porque (d n) || i (q "oculta" en q && (p = q.hidden): q = V.access (a, "fxshow", {display: j }), f && (q.hidden =! p), p && ha ([a] ,! 0), m.done (function () {p || ha ([a]), V.remove (a, "fxshow" ), porque (d n) r.style (a, d, n [d])})), i = eb (p q [d]: 0, d, m), d el q || (q? [d] = i.start, p &&(I.end = i.start, i.start = 0))}} gb función (a, b) {var c, d, e, f, g, porque (c en a) si (d = r.camelCase (c), e = b [d], f = a [c], r.isArray (f) && (e = f [1], f = a [c] = f [0]), c! == d && (un [d] = f, eliminar un [c]), g = r.cssHooks [d], g && "ampliar" en g) {f = g.expand (f), eliminar un [d]; para ( c en f) c || en un (a [c] = f [c], b [c] = e)} else b [d] = e} function hb (a, b, c) {var d, e ., f = 0, g = hb.prefilters.length, h = r.Deferred () siempre (function () {} i.elem borrar), i = function () {if (e) return 1;! a ( var b = Za || cb (), c = Math.max (0, + j.startTime j.duration-b), d = c / j.duration || 0, f = 1-d, g = 0, i = j.tweens.length; g <i; g ++) j.tweens [g] .run (f); h.notifyWith volver (a, [j, f, c]), f <1 && i c:? (h .resolveWith (a, [j]) ,! 1)}, j = h.promise ({elem: a, los apoyos: r.extend ({}, b), opta: r.extend (0, {specialEasing: {}, aliviando: r.easing._default}, c), originalProperties: b, originalOptions: C, horaInicio: Za || cb (), duración: c.duration, tweens: [], createTween: function (b, c ) {var d = r.Tween (a, j.opts, b, c, j.opts.specialEasing [b] || j.opts.easing); j.tweens.push retorno (d), d}, detener : function (b) {var c = 0, d = b j.tweens.length:? 0; si (e) volver esto, porque (e = 0; c <d, c ++!) j.tweens [C]. ejecutar (1); b retorno (h.notifyWith (a, [j, 1,0]), h.resolveWith (a, [j, b])):? h.rejectWith (a, [j, b]) , esto}}), k = j.props; for (gb (k, j.opts.specialEasing); f <g; f ++) si (D = hb.prefilters [f] .call (J, a, K, j.opts)) volver r.isFunction (d.stop) && (r._queueHooks (j.elem, j.opts.queue) .Stop = r.proxy (d.stop, d)), d; r retorno. mapa (k, eb, j), r.isFunction (j.opts.start) && j.opts.start.call (a, j), r.fx.timer (r.extend (i, {elem: una, anim : j, cola: j.opts.queue})), j.progress (j.opts.progress) .done (j.opts.done, j.opts.complete) .fail (j.opts.fail) .always (j.opts.always)} = r.Animation r.extend (Hb, {{tweeners: "*": [función (a, b) {var c = this.createTween (a, b); ea retorno (c .ELEM, a, aa.exec (b), c), c}]}, tweener:? función (a, b) {r.isFunction (a) (b = a, a = [ "*"]): a = a.match (K); for (var c, d = 0, e = a.length; d <e, d ++) c = a [d], hb.tweeners [c] = hb.tweeners [c] || [], hb.tweeners [c] .unshift (b)}, prefiltros: [FB], prefiltro:? la función (a, b) {b hb.prefilters.unshift (a): hb.prefilters.push ( a)}}), r.speed = function (a, b, c) {var e = && un "objeto" == typeof un r.extend ({}, a): {completa:?! c || c && b | | r.isFunction (a) && una, duración: una, aliviando: c && b || b && r.isFunction (b) && b}; volver r.fx.off || d.hidden e.duration = 0:!? "número" ! = typeof e.duration && (e.duration en r.fx.speeds e.duration = r.fx.speeds [e.duration]:? = e.duration r.fx.speeds._default)!, null = e. Cola && e.queue! == 0 || (e.queue = "FX"), e.old = e.complete, e.complete = function () {r.isFunction (e.old) && e.old.call ( este), e.queue && r.dequeue (esto, e.queue)}, e}, r.fn.extend ({fadeTo: function (a, b, c, d) {return this.filter css (ca) ( "opacidad", 0) .show () end () animar ({opacidad: b}.., a, c, d)}, animado: function (a, b, c, d) {var e = r.isEmptyObject (a), f = r.speed (b, c, d), g = function () {var b = hb (esto, r.extend ({}, a), f), (e || V.get (esto, "terminar")) && b.stop (0)}; volver g.finish = g, e || f.queue === 1 this.each (g): this.queue (f.queue!? , g)}, se detiene: la función (a, b, c) {var d = function (a) {var b = a.stop; borrar a.stop, b (c)}; return "cadena" = typeof a &&! (c = b, b = a, a = 0 nula), b && a! ==! 1 && this.queue (a || "FX", []), this.each (function () {var b = 0, e = null = a && a + "queueHooks", f = r.timers, g = V.get (este); if (e) g [e] && g [e] .Stop && d (g [e]); los demás por (e en g) g [e] && g [e] .Stop && ab.test (e) && d (g [e]); for (e = f.length; e -;!) f [e] == .ELEM esta || nula! = a && f [e] .queue! == a || (f [e] .anim.stop (c), b =! 1, f.splice (e, 1)) ;! b && c || r.dequeue (esto, a)})}, final: function (! a) {return a == 1 && (a = a || "FX"), this.each (function () {var b, c = V.get (este), c = d [a + "cola"], e = c + "[a] queueHooks", f = r.timers, g = d D.Longitud: 0; para (c.finish = 0, r .queue (esto, una, []), e && && e.stop e.stop.call (esto, 0), b = f.length; b -;) f [b] .ELEM === esta && f [b]. === cola de un && (f [b] .anim.stop (0), f.splice (b, 1)!), porque (b = 0, b <g; b ++) d [b] && d [b]. terminar && d [b] .finish.call (este); eliminar c.finish})}}), r.each ([ "cambiar", "espectáculo", "ocultar"], la función (a, b) {var c = r.fn [b]; r.fn [b] = function (a, d, e) {return nula == a || "booleano" == typeof un c.apply (esto, argumentos):? this.animate (db (b, 0), a, d, e!)}}), r.each ({slideDown: db ( "show"), slideUp: db ( "ocultar"), slideToggle: db ( "cambiar") , fadeIn: {opacidad: "espectáculo"}, fadeOut: {opacidad: "ocultar"}, fadeToggle: {opacidad: "cambiar"}}, la función (a, b) {r.fn [a] = función (a, c, d) {return this.animate (b, a, c, d)}}), r.timers = [], r.fx.tick = function () {var a, b = 0, c = r. temporizadores, porque (Za = r.now (b); <c.length; b ++)! a = [b] C, a () || c [b] == un c.splice || (B--, 1); c.length || r.fx.stop (), Za = void 0}, r.fx.timer = función (a) {r.timers.push (a), un () r.fx?. start (): r.timers.pop ()}, r.fx.interval = 13, r.fx.start = function () {$ a || ($ a = a.requestAnimationFrame a.requestAnimationFrame (bb)?: ? a.setInterval (r.fx.tick, r.fx.interval))}, r.fx.stop = function () {a.cancelAnimationFrame a.cancelAnimationFrame ($ a): a.clearInterval ($ a), $ a = null}, r.fx.speeds = {lenta: 600, rápido: 200, _default: 400}, r.fn.delay = function (b, c) {return b = r.fx r.fx.speeds [b] || b: b, c = c || "FX", this.queue (c, la función (c, d) {var e = a.setTimeout (c, b); d.stop = function () {a.clearTimeout (e)}})}, function () {var a = d.createElement ( "entrada"), b = d.createElement ( "select"), c = b.appendChild (d.createElement ( " opción! ")); a.type =" casilla de verificación ", o.checkOn =" "== a.value, o.optSelected = c.selected, a = d.createElement (" entrada "), a.value =" t ", a.type =" radio ", o.radioValue =" t "=== a.value} (); ib var, jb = r.expr.attrHandle; r.fn.extend ({attr: function ( a, b) {return S (esto, r.attr, a, b, arguments.length> 1)}, removeAttr: function (a) {return this.each (function () {r.removeAttr (esto, a) })}}), r.extend ({attr:!!! función (a, b, c) {var d, e, f = a.nodeType; si (3 == f && 8 == == f && 2 f) de retorno "indefinido" == typeof a.getAttribute? r.prop (a, b, c) :( 1 === f && r.isXMLDoc (a) || (e = r.attrHooks [b.toLowerCase ()] || ( r.expr.match.bool.test (b) ib: void 0)),
void 0 == === nula c c r.removeAttr vacío (a, b):?!?! e && "set" en e && vacío 0 == (d = e.set (a, c, b)) d?: (a.setAttribute (b, c + ""), c): e && "llegar" en e && nula == (d = e.get (a, b)) d:!? (d = r.find.attr (a, b), d == nula nula 0: d))}, attrHooks: {type: {conjunto: la función (a, b) {if (o.radioValue && "radio" === b && r.nodeName (un " de entrada ")) {var c = a.value; volver a.setAttribute (" tipo ", b), c && (a.value = c), b}}}}, removeAttr: function (a, b) {var c , d = 0, e = b && b.match (K), si (e && 1 === a.nodeType), mientras que (c = e [d ++]) a.removeAttribute (c)}}), ib = {set: function ( a, b, c) {return b === 1 r.removeAttr (a, c):? a.setAttribute (c, c), c}}, r.each (r.expr.match.bool.source .match (/ \ w + / g), la función (a, b) {var c = jb [b] || r.find.attr; jb [b] = function (a, b, d) {var e, f , g = b.toLowerCase (); || retorno d (f = jb [g], jb [g] = e, e = null = c (a, b, d) g: null, jb [g]!? = f), e}}); var = kb / ^ (entrada ?: | selecto | área de texto botón |) $ / i, = lb / ^ (un ?: | área) $ / i; r.fn.extend ( {prop: la función (a, b) {return S (esto, r.prop, a, b, arguments.length> 1)}, removeProp: function (a) {return this.each (function () {borrar esta [ r.propFix [a] || a]})}}), r.extend ({prop: la función (a, b, c) {var d, e, f = a.nodeType; si (3 == f && 8! ! == f && 2! == f) de retorno 1 === f && r.isXMLDoc (a) (b = || r.propFix [b] || B, e = r.propHooks [b]), void 0 ==! ? c e && "conjunto" en e && vacío 0 == (d = e.set (a, c, b)) d:? a [B] = c: e && "llegar" en e && nula == (d = e!. obtener (a, b)) d: a [b]}, propHooks: {tabIndex: {get: function (a) {var b = r.find.attr (a, "tabindex"); b retorno parseInt (?? b, 10): kb.test (a.nodeName) || lb.test (a.nodeName) && a.href 0:? -1}}}, propFix: { "para": "htmlFor", "clase": "className"}}), o.optSelected || (r.propHooks.selected = {get: function (a) {var b = a.parentNode; retorno b && && b.parentNode b.parentNode.selectedIndex, null}, sistema: función ( a) {var b = a.parentNode; b && (b.selectedIndex, b.parentNode && b.parentNode.selectedIndex)}}), r.each ([ "tabIndex", "readOnly", "maxLength", "cellSpacing", " cellPadding "," rOWSPAN "," frameBorder usemap colspan "," "," "," contentEditable "], function () {r.propFix [this.toLowerCase ()] = esta}); mb de función (a) {var b = a.match (K) || []; b.join retorno ( "")} function nb (a) {return a.getAttribute && a.getAttribute ( "clase") || ""} r.fn.extend ( {addClass: function (a) {var b, c, d, e, f, g, h, i = 0; si (r.isFunction (a)) volver this.each (function (b) {r (esto) .addClass (a.call (esto, b, nb (este)))}); si ( "cadena" == typeof a && a) {b = a.match (K) || []; mientras que (c = esta [ i ++]) si (e = nb (c), d = 1 === c.nodeType && "" + mb (e) + "") {g = 0; while (f = b [g ++]) d.indexOf ( "" + f + "") <0 && (d + = f + ""); h = mb (d), e == h && c.setAttribute (! "clase", h)}} return esta}, removeClass: function (a) {var b, c, d, e, f, g, h, i = 0; si (r.isFunction (a)) volver this.each (function (b) {r (este) .removeClass (a.call ( esto, b, nb (este)))}); if (! arguments.length) volver this.attr ( "clase", ""); si ( "cadena" == typeof a && a) {b = a.match ( K) || []; while (c = esta [i ++]) si (e = nb (c), d = 1 === c.nodeType && "" + mb (e) + "") {g = 0; mientras que (f = b [g ++]), mientras que (d.indexOf ( "" + f + "")> - 1) d = d.replace ( "" + f + "", ""); h = mb (d), ! e == h && c.setAttribute ( "clase", h)}}} devolver este, toggleClass: function (a, b) {var c = typeof a; retorno "booleano" == typeof b && "cadena" === C ? b this.addClass (a):? this.removeClass (a):? r.isFunction (a) this.each (function (c) {r (esto) .toggleClass (a.call (esto, c, nb ( este), b), b)}): this.each (function () {var b, d, e, f, y si ( "cadena" === c) {d = 0, e = r (este), f = a.match (K) || []; mientras que (b = f [d ++]) e.hasClass (b) e.removeClass (b):?! e.addClass (b)} else vacío 0 == a && "booleano"! == || c (b = nb (este), b && V.set (esto ", __ __ className", b), this.setAttribute && this.setAttribute ( "clase", b || una ===! 1? "": V.get (esto ", __ className __") || ""))})}, hasClass: function (a) {var b, c, d = 0, b = "" + a + "", mientras que ( c = esta [d ++]) si (1 === c.nodeType && ( "" + mb (nb (c)) + "") .indexOf (b)> - 1) return 0;}} return 1)! ; var ob = / \ r / g; r.fn.extend ({val: function (a) {var b, c, d, e = esta [0]; {if (arguments.length) de retorno d = r. isFunction (a), this.each (function (c) {var e; 1 === this.nodeType && (e = d a.call (esto, c, r (esto) .val ()):? una, null == e e = "?": "número" == typeof e e + =? "":? r.isArray (e) && (e = r.map (e, la función (a) {return nula == un " ": a +"! "})), b = r.valHooks [this.type] || r.valHooks [this.nodeName.toLowerCase ()], b &&" set "en b && vacío 0 == b.set (esto, e, "valor") || (this.value = e))}); si (e) de retorno b = r.valHooks [e.type] || r.valHooks [e.nodeName.toLowerCase ()], b && "get" en b && vacío 0 == (c = b.get (e, "valor")) c:?!? (c = e.value, "cadena" == typeof c c.replace (ob, "") ?: null == c "": c)}}}), r.extend ({valHooks: {opción: {get: function (a) {var b = r.find.attr (un "valor"); devolver null = b b:!? mb (R.TEXT (a))}}, seleccionar: {get: function (a) {var b, c, d, e = a.options, f = a.selectedIndex, g = "select-uno" === a.type, h = g nula: [], i = f g + 1:?? e.length, porque (d = f <0 i: g f:?? 0; d <i;! d ++) si (c = e [d], (c.selected || d === f) && && c.disabled (c.parentNode.disabled || r.nodeName (c.parentNode,! "optgroup"))) {if (b = r (c) .val (), g) de retorno b; h.push (b)}} h retorno, sistema: la función (a, b) {var c, d, e = a.options, f = r.makeArray (b), g = e.length, mientras que (g -) d = e [g], (d.selected = r.inArray (r.valHooks.option.get (d), f)> - (c 1) && = 0);! devuelva c || (a.selectedIndex = -1), f}}}}), r.each ([ "radio", "casilla de verificación" ], function () {r.valHooks [esto] = {conjunto: la función (a, b) {if (r.isArray (b)) = retorno a.checked r.inArray (r (a) .val (), b)> - 1}}, o.checkOn || (r.valHooks [esto] .get = function (a) {return null === a.getAttribute ( "valor") "en": a.value}? )}); var pb = / ^ (focusinfocus ?: | focusoutblur) $ /; r.extend (r.event, {gatillo: function (b, c, e, f) {var g, h, i, j, k, m, n, o = [e || d], p = l.call (b, "tipo") b.type:?? b, q = l.call (b, "nombre") b.namespace .split ( "."):!!! []; si (h = i = e = e || d, 3 == == 8 e.nodeType && && e.nodeType pb.test (p + r.event.triggered) && (p.indexOf ()> - 1 && (q = p.split (), p = q.shift (), q.sort ()), k = p.indexOf ( "." "." ":") <0 && "en" + p, b = b [r.expando] b:? r.Event nueva (p, "objeto" == typeof b && b), f = b.isTrigger 2: 3, b.namespace = q .join ( "."), b.rnamespace = b.namespace nueva RegExp (| + q.join ( "\\ (.?..: * \\ |)"? "(^ \\).") + "(\\ | $.)"):? nula, b.result = 0 vacío, b.target || (b.target = e), c = null == c [b]: r.makeArray (c, [b]), n = r.event.special [p] || {}, f ||! n.trigger || n.trigger.apply (e, C)! ==! 1)) {if (! f && && n.noBubble r.isWindow (e)) {for (j = n.delegateType || p, pb.test (j + p) || (h = h.parentNode);! h; h = h.parentNode ) o.push (h), i = h; i === (e.ownerDocument || d) && o.push (i.defaultView || || i.parentWindow a)} g = 0; while ((h = o [g ++]) && b.isPropagationStopped ()) = g b.type> j 1:!? n.bindType || p, m = (V.get (h, "eventos") || {}) [b .type] && V.get (h, "mango"), m && m.apply (h, c), m = k && h [k], m && m.apply && T (h) && (b.result = m.apply (h, c) , b.result === 1 && b.preventDefault ());! volver b.type = p, f || b.isDefaultPrevented () || n._default && n._default.apply (o.pop (), c) = =! 1 ||! T (e) k || && r.isFunction (e [p]) &&! r.isWindow (e) && (i = e [k], i && (e [k] = null), r. event.triggered = p, e [p] (), r.event.triggered = 0 nula, i && (e [k] = i)), b.result}}, simulan: function (a, b, c) { var d = r.extend (nueva r.Event, c, {type: una, isSimulated: 0}); r.event.trigger (d, null, b)}}), r.fn.extend ({gatillo : function (a, b) {return this.each (function () {r.event.trigger (a, b, this)})}, triggerHandler: function (a, b) {var c = esta [0]; si (c) r.event.trigger retorno (a, b, c, 0)}}), r.each ( "desenfoque focusin focusOut cambiar el tamaño de pantalla Haga clic cambio dblclick mousedown mouseup mousemove por encima del ratón mouseout MouseEnter mouseleave seleccionar presentar keyup pulsación keydown contextual ".split (" "), la función (a, b) {r.fn [b] = function (a, c) {return arguments.length> 0 this.on (b, nula, a, c)?: this.trigger (b)}}), r.fn.extend ({emergente: la función (a, b) {return this.mouseenter (a) .mouseleave (b || a)}}), o.focusin = " onfocusin "en una, o.focusin || r.each ({enfoque:" focusin ", falta de definición:" focusOut "} function, (a, b) {var c = function (a) {r.event.simulate (b , a.target, r.event.fix (a))}; r.event.special [b] = {configuración: function () {var d = || this.ownerDocument esto, e = V.access (d, b); e || d.addEventListener (! a, c, 0), V.access (d, b, (e || 0) +1)}, desmontaje: function () {var d = this.ownerDocument | | esto, e = V.access (d, b) -1;? e V.access (d, b, e) :( d.removeEventListener (! a, c, 0), V.remove (d, b) )}}}); var = qb a.location, rb = r.now (), sb = / \ /;? r.parseXML = function (b) {var c; si (b || "cadena"! = typeof b) return null;! try {c = (nueva a.DOMParser) .parseFromString (b, "text / xml")} catch (d) {c = 0} void retorno c && c.getElementsByTagName ( "parsererror") .length || r.error ( "XML no válido:" + b), c}; var = tb / \ [\] $ /, = ub / \ r \ n / g, VB = / ^ (?: presentar? botón | | imagen | restablecer | archivo) $ / i, wb = / ^ (entrada ?: | selecto | área de texto | keygen) / i; xb función (a, b, c, d) {var correo; si (r. isArray (b)) r.each (b, la función (b, e) {c || tb.test (a) d (a, e):? xb (a + "[" + ( "objeto" == typeof e && nula !? = e B: "") + "]", e, c, d)}); else if (c || "objeto" == r.type (b)) d (a, b); otra cosa! para (e en b) xb (a + "[" + e + "]", b [e], c, d)} r.param = function (a, b) {var c, d = [], e = function ? (a, b) {var c = r.isFunction (b) b (): b, d [D.Longitud] = encodeURIComponent (a) + "=" + encodeURIComponent (? nula == c "": c) }; si (r.isArray (a) || a.jquery && r.isPlainObject (a)!) r.each (a, function () {e (this.name, this.value)}); los demás por (c en a) xb (c, a [c], b, e); return d.join ( "y")}, r.fn.extend ({serializar: function () {r.param retorno (this.serializeArray ( ))}, serializeArray: function () {return this.map (function () {var a = r.prop (esto, "elementos"); devuelven un r.makeArray (a): esto?}) filtro (función. () {var a = this.type; volver this.name && r (este) .IS ( ": desactivado")! && wb.test (this.nodeName) && vb.test (a) && (this.checked || !. (a))}) mapa ia.test (función (a, b) {var c = r (esto) .val (); devolver null == c null:?? r.isArray (c) r.map (c, la función (a) {return {nombre: b.name, valor: a.replace (UB, "\ r \ n")}}): {name: b.name, valor: c.replace (UB, "\ r \ n")}}) get ()}});.. [? &] var YB = /% 20 / g, zb = / # * $ /, Ab = / () _ = [^ & ] * /, Bb = / ^ (.? *): [\ t] * ([^ \ r \ n] *) $ / g, Cb = / ^ (sobre ?: | aplicación | app-storage | +. -Ampliación | archivo | res | Reproductor): $ /, Db = / ^ (GET ?: | HEAD) $ /, Eb = / ^ \ / \ //, Fb = {}, S = {}, Hb = " * / "(*"), Ib = d.createElement ( "a"); Ib.href = qb.href; Jb función (a) {función de retorno (b, c) { "concat."! cadena "= typeof b && (c = b, b = "*"); var d, e = 0, f = b.toLowerCase () partido (K) || [];. Si (r.isFunction (c)), mientras que (d = f [e ++]) "+" === d [0]? (d = d.slice (1) || "*", (una [d] = a [d] || []). unshift (c )) :( a [d] = a [d] || []). empuje (c)}} function Kb (a, b, c, d) {var e = {}, f = a === Gb ; función g (h) {var i;! declaración electrónica [h] = 0, r.each (una [h] || [], la función (a, h) {var j = h (b, c, d) ?!?!; return "cadena" = typeof j || f || e [j] i (i = j): void 0: (b.dataTypes.unshift (j), g (j) ,! 1)} ), i} return g (b.dataTypes [0]) ||! e [ "*"] && g ( "*")} función Lb (a, b) {var C, D, e = r.ajaxSettings.flatOptions || {}; for (c en b) void 0 == b [c] && ((e [c] a:? d || (d = {})) [c] = b [c])!; volver d && r.extend (0, a, d!), una función} Mb (a, b, c) {var d, e, f, g, h = a.contents, i = a.dataTypes, mientras que ( "* "=== i [0]) i.shift (), nula 0 === d && (d = || a.mimeType b.getResponseHeader (" Content-Type ")); si (d) de (e en h ) si (h [e] && h [e] .test (d)) {i.unshift (e); descanso} if (i [0] en c) f = i [0]; else {a (e en c ) {if (i [0] || a.converters [e + "" + i [0]]) {f = e;! descanso} || g (g = e)} f = f || g} if ( f) la devolución f! == i [0] && i.unshift (f), c [f]} la función de Nb (a, b, c, d) {var e, f, g, h, i, j = {} , k = a.dataTypes.slice (), si (k [1]) por (g en a.converters) j [g.toLowerCase ()] = a.converters [g]; f = k.shift (); mientras que (f) si (a.responseFields [f] && (c [a.responseFields [f]] = b) ,! i && && d a.dataFilter && (b = a.dataFilter (b, a.dataType)), i = f, f = k.shift ()) si ( "*" === f) f = i;! else if ( "*" == == i && i f) {if (g = j [i + "" + f] || j [ "*" + f] ,! g) de (e en la j) si (h = e.split ( ""), h [1] === f && (g = j [i + "" + h [0]] || [j "*" + h [0]])) {g === 0 g = j [e]:!?! j [e] == 0 && (f = h [0] , k.unshift (h [1])); descanso} if (g == 0) si (g && un [ "tiros"]) b = g (b);!! else try {b = g (b)} catch (l) {return {estado: "parsererror", error:? g l: "Sin la conversión de" + i + "a" f +}}} return {estado: "éxito", los datos: b}} r.extend ( {activa: 0, LastModified: {}, etag: {}, ajaxSettings: {url: qb.href, tipo: "GET", isLocal: Cb.test (qb.protocol), global: 0, processData: 0 , asincrónico: 0, contentType: "application / x-www-form-urlencoded; charset = UTF-8 ", acepta: {" * ": Hb, texto:" text / plain ", html:" text / html ", xml:" application / xml, text / xml ", JSON:" application / json , text / javascript "}, contenidos: {xml: / \ bxml \ b /, html: / \ bhtml /, JSON: / \ bjson \ b /}, responseFields: {xml:" responseXML ", texto:" responseText " , JSON: "responseJSON"}, convertidores: { "* texto": cadena, "texto html": 0 ", el texto JSON": JSON.parse, "texto XML": r.parseXML}, flatOptions: {url: ! 0, contexto: 0}}, ajaxSetup:? la función (a, b) {return b Lb (Lb (a, r.ajaxSettings), b): LB (r.ajaxSettings, a)}, ajaxPrefilter: Jb ( Fb), ajaxTransport: Jb (Gb), Ajax: function (b, c) { "objeto" == typeof b && (c = b, b = 0 nula), c = c || {}; var e, f, g, h, i, j, k, l, m, n, o = r.ajaxSetup ({}, c), p = o.context || o, q = o.context && (p.nodeType || p. jQuery) r (p):? r.event, s = r.Deferred (), t = r.Callbacks ( "una vez que la memoria"), u = o.statusCode || {}, {} = v, w = { }, x = "cancelados", y = {readyState: 0, getResponseHeader: function (a) {var b; si (k) {if (! h) {h = {}; mientras que (b = Bb.exec (g )) h [b [1] .tolowercase ()] = b [2]} b = h [a.toLowerCase ()]} devuelven null == b nulo:? b}, getAllResponseHeaders: function () {return k? g: null}, setRequestHeader: function (a, b) {return null == k && (a = w [a.toLowerCase ()] = w [a.toLowerCase ()] || a, v [a] = b) , esto}, overrideMimeType: function (a) {return null == k && (o.mimeType = a), esto}, statuscode: function (a) {var b; si (a) si (k) y.always (una [y.status]); los demás por (b en a) u [b] = [u [b], un [b]]; retorno este}, abortar: function (a) {var b = a x ||; volver e && e.abort (b), A (0, b), esto}}; si (s.promise (y), o.url = ((b || || o.url qb.href) + "") .Colocar (Eb, qb.protocol + "//"), o.type = || c.method c.type || || o.method o.type, o.dataTypes = (o.dataType || "*" ) .tolowercase partido () (K) || [ ""], null == o.crossDomain) {j = d.createElement ( "a");. try {j.href = o.url, j.href = j.href, o.crossDomain = Ib.protocol + "//" + Ib.host! = j.protocol + "//" + j.host} catch (z) = {o.crossDomain 0}} if (o. && && datos o.processData "cadena" = typeof O.Data && (O.Data = r.param (O.Data, o.traditional)), Kb (Fb, O, C, y), k) y de retorno;! l = r .Los && o.global, l && 0 === r.active ++ && r.event.trigger ( "ajaxStart"), o.type = o.type.toUpperCase (), o.hasContent =! Db.test (o.type) , f = o.url.replace (ZB, ""), o.hasContent? O.Data && && o.processData 0 === (o.contentType || ""). indexOf ( "application / x-www-form-urlencoded" ) && (O.Data = o.data.replace (YB, "+")) :( n = o.url.slice (f.length), O.Data && (f + = (sb.test (f)? " & ":"? ") + O.Data, eliminar O.Data), o.cache === 1 && (f = f.replace (Ab," $ 1 "), n = (sb.test (f)? "&": "?") + "_ =" + rb ++ + n), o.url = f + n), o.ifModified && (r.lastModified [f] && y.setRequestHeader ( "If-Modified-Since", r.lastModified [f]), r.etag [f] && y.setRequestHeader ( "If-None-Match", r.etag [f])), (O.Data && && o.hasContent o.contentType! ==! 1 || c.contentType) && y.setRequestHeader ( "Content-Type", o.contentType), y.setRequestHeader ( "Aceptar", o.dataTypes [0] [&& o.accepts o.dataTypes [0]] [o o.accepts? .dataTypes [0]] + ( "*" == o.dataTypes [0] "," + Hb + "!?; q = 0,01 ":" "): o.accepts [" * "]); para (m en o.headers) y.setRequestHeader (m, o.headers [m]); si (o.beforeSend && (o.beforeSend .call (p, y, o) === 1 || k)) de retorno y.abort (); if (x = "abortar", t.add (o.complete), y.done (o.success ), y.fail (o.error), e = Kb (Gb, O, C, y)) {if (y.readyState = 1, l && q.trigger ( "ajaxSend", [y, o]), k) y volver; o.async && o.timeout> 0 && (i = a.setTimeout (function () {y.abort ( "tiempo de espera")}, o.timeout));! try {k = 1, e.send (v, A)} catch (z) z {if (k) de banda; A (-1, z)}} else A (-1, "no hay transporte"); función A (b, c, d, h) {var j , m, n, v, w, x = c;! k || (k = 0, i && a.clearTimeout (i), e = 0 vacío, g = h || "", y.readyState = b> 0? 4: 0, j = b> = 200 && b <300 || 304 === b, d && (v = Mb (O, y, d)), v = Nb (o, v, y, j), j (? o.ifModified && (w = y.getResponseHeader ( "última actualización"), w && (r.lastModified [f] = w), w = y.getResponseHeader ( "etag"), w && (r.etag [f] = w )), 204 === b || "HEAD" === o.type x = "nocontent":?? 304 === b x = "notmodified" :( x = v.state, m = v.data , n = v.error, j = n)) :( n = x,! b && || x (x = "error", b <0 && (b = 0))), y.status = b, y.statusText = (c || x) + "", j s.resolveWith (p, [m, x, y]):? s.rejectWith (p, [y, x, n]), y.statusCode (u), u = 0 vacío, l && q.trigger (j "ajaxSuccess": "ajaxError", [y, o, j m: n]), t.fireWith (p, [y, x]), l && (q.trigger ( "ajaxComplete", [y, o]), - || r.active r.event.trigger ( "ajaxStop")))}} return y, getJSON: function (a, b, c) {return r. obtener (a, b, c, "json")}, getScript: function (a, b) {r.get retorno (a, 0 nula, b, "script")}}), r.each ([ "llegar "," post "], la función (a, b) {r [b] = function (a, c, d, e) {return r.isFunction (c) && (e = e || D, D = c, c = 0 nula), r.ajax (r.extend ({url: una, tipo: b, tipoDatos: correo, los datos: c, el éxito: d}, r.isPlainObject (a) && a))}}), r ._evalUrl = function (a) {r.ajax retorno ({url: una, tipo: "GET", tipoDatos: "guión", caché: 0, asincrónico: 1, global: 1, "lanza" :! 0})}, r.fn.extend ({wrapAll: function (a) {var b; devolver esta [0] && (r.isFunction (a) && (a = a.call (esto [0])), b = r (a, esta [0] .ownerDocument) .EQ (0) .clone (0), esta [0] .parentNode && b.insertBefore (esto [0]), b.map (function () {var una = este, mientras que (a.firstElementChild) a = a.firstElementChild; volver a}) append (este)), esto}, wrapInner: function (a) {return r.isFunction (a) this.each (function (.? b) {r (este) .wrapInner (a.call (esto, b))}): this.each (function () {var b = r (este), c = b.contents (); c.length? c.wrapAll (a): b.append (a)})}, envoltura: la función (a) {var b = r.isFunction (a); volver this.each (function (c) {r (este) .wrapAll (b a.call (esto, c):? a)})}, desenvuelva: function (a.) {return this.parent (a) .no ( "cuerpo") cada uno (function () {r (esto) .replaceWith (this.childNodes)}), esto}}), r.expr.pseudos.hidden = function (a) {return! r.expr.pseudos.visible (a)}, r.expr.pseudos.visible = la función (a) {return !! (a.offsetWidth || || a.offsetHeight a.getClientRects (). de longitud)}, r.ajaxSettings.xhr = function () {try {return new a.XMLHttpRequest} catch (b ) {}}; var Ob = {0: 200,1223: 204}, Pb = r.ajaxSettings.xhr (); o.cors = Pb !! && "withCredentials" en Pb, Pb o.ajax = = Pb !! !, r.ajaxTransport (function (b) {var c, d; devolución si (Pb o.cors || && b.crossDomain) {enviar: function (e, f) {var g, h = b.xhr (); si (h.open (b.type, b.url, b.async, b.username, b.password), b.xhrFields) por (g en b.xhrFields) h [g] = b.xhrFields [g] ; b.mimeType && && h.overrideMimeType h.overrideMimeType (b.mimeType), b.crossDomain || e [ "X-Requested-Con"] || (e [ "X-Requested-Con"] = "XMLHttpRequest"); for ( g en e) h.setRequestHeader (g, e [g]); c = function (a) {función de retorno () {c && (c = d = = h.onload h.onerror = h.onabort = = h.onreadystatechange null, "abortar" === una h.abort ():? "error" === un "número" = typeof h.status f (0, "error"):?!? f (h.status, h .statusText): f (Ob [h.status] || h.status, h.statusText, "texto" == (h.responseType || "texto"!) || "cadena" = typeof h.responseText!? {binaria: h.response}: {text: h.responseText}, h.getAllResponseHeaders ()))}}, h.onload = c (), d = h.onerror = c ( "error"), nula 0! == h.onabort h.onabort = d:? h.onreadystatechange = function () {4 === h.readyState && a.setTimeout (function () {c && d ()})}, c = c ( "abortar"); try {h.send (b.hasContent && || B.Data nulo)} catch (i) {if (c) tiro i}}, abortar: function () {c && c ()}}}), r.ajaxPrefilter (function ( a) {! a.crossDomain && (a.contents.script = 1)}), r.ajaxSetup ({acepta: {guión: "text / javascript, application / javascript, application / ECMAScript, application / x-ecmascript"}, contenido: {secuencia de comandos: / \ b: | guión \ b / (java ECMA?)}, convertidores: { "escritura de texto": la función (a) {return r.globalEval (a), a}}}), r. ajaxPrefilter ( "guión", la función (a) {void 0 === a.cache && (a.cache =! 1), a.crossDomain && (a.type = "GET")}), r.ajaxTransport ( "guión" , la función (a) {if (a.crossDomain) {var b, c; retorno {enviar:. función (e, f) {b = r ( "<script>") prop ({charset: a.scriptCharset, src :. a.url}) en ( "error de carga", c = function (a) {b.Retire (), c = null, a && f ( "error" === a.type 404: 200, a.type )}), d.head.appendChild (b [0])}, abortar:?? function () {c && c ()}}}}); var Qb = [], Rb = / (=) \ (= & | $) | \ \ /; r.ajaxSetup ({jsonp: "callback", jsonpCallback: function ()?? {var a = Qb.pop () || r.expando + "_" + rb ++; devuelva esta [a ] = 0, a}}), r.ajaxPrefilter ( "JSON jsonp", la función (b, c, d) {var e, f, g, h = b.jsonp! ==! 1 && (Rb.test ( ? b.url) "url": "cadena" == 0 && typeof B.Data === (b.contentType || "application / x-www-form-urlencoded") && Rb.test (b ") indexOf (". ? .data) && "datos"); si (h || "jsonp" === b.dataTypes [0]) de retorno e = = b.jsonpCallback r.isFunction (b.jsonpCallback) b.jsonpCallback (): b .jsonpCallback, b h [h] = b [h] .Colocar (Rb, "$ 1" + e):?! b.jsonp == 1 && (b.url + = (sb.test (b.url) "? & ":"? ") + b.jsonp +" = "+ e), b.converters [" JSON guión "] = function () {return g || r.error (e +" no se llamaba "), g [ 0]}, b.dataTypes [0] = "json", f = a [e], una [e] = function () {g} = argumentos, d.always (function () {void 0 === f ? r (a) .removeProp (e): a [e] = f, b [e] && (b.jsonpCallback = c.jsonpCallback, Qb.push (e)), g && r.isFunction (f) && f (g [ 0]), g = f = 0} void), "guión"}), o.createHTMLDocument = function () {a = d.implementation.createHTMLDocument ( "") del cuerpo.; volver a.innerHTML = "var <form > </ form> <form> </ form> ", 2 === a.childNodes.length} (), r.parseHTML = function (a, b, c) {if (" cadena "! = typeof a) volver []; "booleano" == typeof b && (c = b, b = 1!); var e, f, g,? b || retorno (o.createHTMLDocument (b = d.implementation.createHTMLDocument ( "") , e = b.createElement ( "base"), e.href = d.location.href, b.head.appendChild (e)): b = d), f = B.exec (a), g = c && [], f? [b.createElement (f [1])] :( f = pa ([a], b, g), g && && g.length r (g) .Remove (), r.merge ([], f .childNodes))}, r.fn.load = function (a, b, c) {var d, e, f, g = esto, h = a.indexOf ( ""); retorno h> -1 && (d = ? mb (a.slice (h)), a = a.slice (0, h)), r.isFunction (b) (c = b, b = 0 nula): b && "objeto" == typeof b && (e = "POST"), g.length> 0 && r.ajax ({url: una, tipo: e || "GET", tipoDatos: "html", los datos: b}.) hecho (función (a) {f = argumentos , g.html (d r ( "<div>") append (r.parseHTML (a)) se encontró (d):?.. a).}) siempre (&& función c (a, b) {g.each (función () {c.apply (esto, f || [a.responseText, b, a])})}), esta}, r.each ([ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError" , "ajaxSuccess", "ajaxSend"], la función de (a, b) {r.fn [b] = función (a) {return this.on (b, a)}}), r.expr.pseudos.animated = función (a) {return r.grep (r.timers, la función (b) {return un b.elem ===}) de longitud.}; función de Sb (a) {return r.isWindow (a) a: 9? === a.nodeType && a.defaultView} r.offset = {setOffset: function (a, b, c) {var d, e, f, g, h, i, j, k = r.css (una posición " "), l = r (a), m = {};" estática "=== k && (a.style.position =" relativo "), h = l.offset (), f = r.css (a, "superior"), i = r.css (a, "izquierda"), j = ( "absoluta" === k || "fijo" === k) && (f + i) .indexOf ( "auto" )> - 1, j (d = l.position (), g = d.top, e = Día D.left) :( g = parseFloat (f) || 0, e = parseFloat (i) || 0) , r.isFunction (b) && (b = b.call (a, c, r.extend ({}, h))), null! = b.top && (m.top = + b.top-h.top g), null && = b.left (m.left = b.left-h.left + e), el "uso" en b b.using.call (a, m):? l.css (m)}} , r.fn.extend ({offset: la función (a) {if (arguments.length) de retorno void 0 === un presente:? this.each (function (b) {r.offset.setOffset (esto, una, b)}); var b, c, d, e, f = esta [0]; si (f) f.getClientRects de retorno () longitud (d = f.getBoundingClientRect (), d.width || d.?. altura (e = f.ownerDocument, c = Sb (e), b = e.documentElement, {top:? d.top + c.pageYOffset-b.clientTop, izquierda: Día D.left + c.pageXOffset-b.clientLeft }): d): {top: 0, izquierda: 0}}, la posición: function () {if (esto [0]) {var a, b, c = esta [0], d = {top: 0, izquierda: 0}; retorno "fijo" === r.css (c, "posición") b = c.getBoundingClientRect () :( a this.offsetParent = (), b = this.offset (), r?. nombreNodo (a [0], "hTML") || (d = a.offset ()), d = {top: d.top + r.css (a [0], "borderTopWidth", 0), izquierda : Día D.left + r.css (a [0], "borderLeftWidth", 0)}), {top: b.top-d.top-r.css (c, "marginTop", 0), dejó : b.left-r.css-Día D.left (! c, "marginLeft", 0)}}}, offsetParent: function () {return this.map (function () {var a = this.offsetParent, mientras que ( a && "estática" === r.css (una "posición")) a = a.offsetParent; devolver un qa ||})}}), r.each ({scrollLeft: "pageXOffset", scrollTop: "pageYOffset "}, la función (a, b) {var c =" pageYOffset "=== b; r.fn [a] = function (d) {return S (esto, la función (a, d, e) {var f = Sb (a); vuelve vacía 0 === e f f [b]: a [d]: void (f f.scrollTo (c f.pageXOffset: e, C e: f.pageYOffset):????? un [d] = e)}, a, d, arguments.length)}}), r.each ([ "izquierda" "superior"], la función (a, b) {r.cssHooks [b] = Oa ? (o.pixelPosition, la función (a, c) {if (c) el retorno c = Na (a, b), La.test (c) r (a) .position () [b] + "px": c })}), r.each ({altura: "altura", ancho: "anchura"}, la función (a, b) {r.each ({padding: "interior" + a, contenido: b, "": "externa" + a}, la función (c, d) {r.fn [d] = function (e, f) {var g = arguments.length && (c || "booleanos"! = typeof e), h = c || (e === === 0 || f 0 "margen":!? "frontera"); return S (esto, la función (b, c, e) {var f; volver r.isWindow (b ??) 0 === d.indexOf ( "externa") b [ "interior" + a]: b.document.documentElement [ "cliente" + a]: 9 === b.nodeType (f = b?. documentElement, Math.max (b.body [ "scroll" + a], f [ "scroll" + a], b.body [ "compensada" + a], f [ "compensar" + a], f [ "cliente "+ a])):? nula 0 === e r.css (b, c, h):? r.style (b, c, e, h)}, b, g e: void 0, g) }})}), r.fn.extend ({aprieto: la función (a, b, c) {return this.on (a, nula, b, c)}, desenlaza: function (a, b) {return este .OFF (a, nula, b)}, delegado: function (a, b, c, d) {return this.on (b, a, c, d)}, undelegate: function (a, b, c) { volver 1 arguments.length === this.off (a, "**"):? this.off (b, a || "**", c)}}), r.parseJSON = JSON.parse " función "== typeof definir && && define.amd define (" jQuery ", [], la función () {return r}); Tb var = a.jQuery, Ub = a $;. regresar r.noConflict = function (b) {return una . $ === r && (a. $ = Ub), b && a.jQuery === r && (a.jQuery = Tb), r}, b || (a.jQuery = a. $ = r), r}) ;